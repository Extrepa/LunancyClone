<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Design Tool - Lunacy Clone</title>
  <link rel="stylesheet" href="css/main.css">
</head>
<body>
  <!-- Toolbar -->
  <div class="toolbar">
    <button class="tool-btn active" data-tool="select" data-tooltip="Select (V)" title="Select tool">‚Üñ</button>
    <button class="tool-btn" data-tool="frame" data-tooltip="Frame (A)" title="Frame tool">‚ñ¢</button>
    <div style="position: relative;">
      <button class="tool-btn" data-tool="shape" data-tooltip="Shapes (R/L/O)" title="Shape tools">‚óá</button>
      <div class="shape-submenu" id="shapeSubmenu">
        <button class="shape-btn" data-shape="rect">Rectangle (R)</button>
        <button class="shape-btn" data-shape="rounded">Rounded Rectangle (R, R)</button>
        <button class="shape-btn" data-shape="line">Line (L)</button>
        <button class="shape-btn" data-shape="arrow">Arrow (L, L)</button>
        <button class="shape-btn" data-shape="oval">Oval (O)</button>
        <button class="shape-btn" data-shape="triangle">Triangle (O, O)</button>
        <button class="shape-btn" data-shape="polygon">Polygon (O, O, O)</button>
        <button class="shape-btn" data-shape="star">Star (O, O, O, O)</button>
      </div>
    </div>
    <button class="tool-btn" data-tool="text" data-tooltip="Text (T)" title="Text tool">T</button>
    <button class="tool-btn" data-tool="pen" data-tooltip="Pen (P)" title="Pen tool">‚úé</button>
    <button class="tool-btn" data-tool="pencil" data-tooltip="Pencil (P, P)" title="Pencil tool">‚úè</button>
    <button class="tool-btn" data-tool="image" data-tooltip="Image (M)" title="Image tool">üñº</button>
    <button class="tool-btn" data-tool="gui" data-tooltip="GUI (B/D/F/Y/J/W)" title="GUI tool">‚ñ°</button>
    <button class="tool-btn" data-tool="icon" data-tooltip="Icon (X)" title="Icon tool">‚òÖ</button>
    <button class="tool-btn" data-tool="comment" data-tooltip="Comment (C)" title="Comment tool">üí¨</button>
    <button class="tool-btn" data-tool="scale" data-tooltip="Scale (K)" title="Scale tool">‚á±</button>
    <button class="tool-btn" data-tool="eyedropper" data-tooltip="Eyedropper (I)" title="Eyedropper tool">üîç</button>
    <button class="tool-btn" data-tool="hand" data-tooltip="Hand (Space)" title="Hand tool">‚úã</button>
    <button class="tool-btn" data-tool="hotspot" data-tooltip="Hotspot (H)" title="Hotspot tool">üìç</button>
    <button class="tool-btn" data-tool="slice" data-tooltip="Slice (E)" title="Slice tool">‚úÇ</button>
    <button class="tool-btn" data-tool="avatar" data-tooltip="Avatar (Q)" title="Avatar tool">üë§</button>
    <button class="tool-btn" data-tool="component" data-tooltip="Component (S)" title="Component tool">üß©</button>
    <button class="tool-btn" data-tool="rotate" data-tooltip="Rotate Copies (‚åò‚áßB)" title="Rotate copies tool">‚Üª</button>
  </div>

  <!-- Main Content -->
  <div class="canvas-container">
    <div class="top-bar">
      <h1>Design Tool</h1>
      <div class="top-bar-actions">
        <button class="btn" id="exportBtn">Export</button>
        <button class="btn btn-primary" id="saveBtn">Save</button>
      </div>
    </div>
    <canvas class="canvas select-mode" id="canvas"></canvas>
    <div class="status-bar">
      <span id="statusText">Ready</span>
      <span style="margin-left: auto;" id="zoomText">100%</span>
    </div>
  </div>

  <!-- Right Panel -->
  <div class="right-panel">
    <div class="layers-panel">
      <h3>Layers</h3>
      <ul class="layers-list" id="layersList"></ul>
    </div>
    <div class="panel-section">
      <h3>Properties</h3>
      <div class="panel-control">
        <label>Fill Type</label>
        <select id="fillType">
          <option value="solid">Solid</option>
          <option value="gradient">Gradient</option>
        </select>
      </div>
      <div class="panel-control" id="fillColorControl">
        <label>Fill Color</label>
        <input type="color" id="fillColor" class="color-picker" value="#4a9eff">
      </div>
      <div class="panel-control" id="gradientControls" style="display: none;">
        <label>Gradient Start</label>
        <input type="color" id="gradientStart" class="color-picker" value="#4a9eff">
        <label style="margin-top: 8px;">Gradient End</label>
        <input type="color" id="gradientEnd" class="color-picker" value="#3a8eef">
        <label style="margin-top: 8px;">Gradient Direction</label>
        <select id="gradientDirection">
          <option value="horizontal">Horizontal</option>
          <option value="vertical">Vertical</option>
          <option value="diagonal">Diagonal</option>
        </select>
      </div>
      <div class="panel-control">
        <label>Stroke Color</label>
        <input type="color" id="strokeColor" class="color-picker" value="#000000">
      </div>
      <div class="panel-control">
        <label>Stroke Width</label>
        <input type="range" id="strokeWidth" min="0" max="20" value="2">
        <span id="strokeWidthValue">2px</span>
      </div>
      <div class="panel-control">
        <label>Opacity</label>
        <input type="range" id="opacity" min="0" max="1" step="0.01" value="1">
        <span id="opacityValue">100%</span>
      </div>
    </div>
    <div class="panel-section" id="textFormatSection" style="display: none;">
      <h3>Text Formatting</h3>
      <div class="panel-control">
        <label>Font Size</label>
        <input type="number" id="fontSize" value="16" min="8" max="200">
      </div>
      <div class="panel-control">
        <label>Font Weight</label>
        <select id="fontWeight">
          <option value="normal">Normal</option>
          <option value="bold">Bold</option>
        </select>
      </div>
      <div class="panel-control">
        <label>Font Style</label>
        <select id="fontStyle">
          <option value="normal">Normal</option>
          <option value="italic">Italic</option>
        </select>
      </div>
      <div class="panel-control">
        <label>Text Align</label>
        <select id="textAlign">
          <option value="left">Left</option>
          <option value="center">Center</option>
          <option value="right">Right</option>
        </select>
      </div>
    </div>
    <div class="panel-section">
      <h3>Transform</h3>
      <div class="panel-control">
        <label>X</label>
        <input type="number" id="posX" value="0">
      </div>
      <div class="panel-control">
        <label>Y</label>
        <input type="number" id="posY" value="0">
      </div>
      <div class="panel-control">
        <label>Width</label>
        <input type="number" id="width" value="100">
      </div>
      <div class="panel-control">
        <label>Height</label>
        <input type="number" id="height" value="100">
      </div>
      <div class="panel-control">
        <label>Rotation</label>
        <input type="range" id="rotation" min="0" max="360" value="0">
        <span id="rotationValue">0¬∞</span>
      </div>
    </div>
    <div class="panel-section">
      <h3>Effects</h3>
      <div class="panel-control">
        <label>Shadow</label>
        <input type="checkbox" id="shadow">
      </div>
      <div class="panel-control">
        <label>Blur</label>
        <input type="range" id="blur" min="0" max="20" value="0">
        <span id="blurValue">0px</span>
      </div>
    </div>
    <div class="panel-section">
      <h3>Auto Layout</h3>
      <div class="panel-control">
        <label>Layout Mode</label>
        <div class="layout-controls">
          <button class="layout-btn" data-layout="none">None</button>
          <button class="layout-btn" data-layout="hstack">H-Stack</button>
          <button class="layout-btn" data-layout="vstack">V-Stack</button>
          <button class="layout-btn" data-layout="grid">Grid</button>
        </div>
      </div>
      <div class="panel-control">
        <label>Padding</label>
        <input type="number" id="layoutPadding" value="8" min="0">
      </div>
      <div class="panel-control">
        <label>Gap</label>
        <input type="number" id="layoutGap" value="8" min="0">
      </div>
      <div class="panel-control">
        <label>Auto Resize</label>
        <input type="checkbox" id="autoResize">
      </div>
    </div>
    <div class="panel-section">
      <h3>Components</h3>
      <div class="panel-control">
        <button class="btn" id="createComponentBtn">Create Component</button>
        <button class="btn" id="detachComponentBtn" style="margin-top: 8px;">Detach Instance</button>
      </div>
      <div id="componentsList" style="margin-top: 12px;"></div>
    </div>
    <div class="panel-section">
      <h3>Asset Library</h3>
      <div class="panel-control">
        <input type="text" id="assetSearch" placeholder="Search assets..." style="width: 100%; margin-bottom: 8px;">
      </div>
      <div class="asset-grid" id="assetGrid">
        <!-- Assets will be populated here -->
      </div>
    </div>
    <div class="panel-section">
      <h3>Comments</h3>
      <div class="panel-control">
        <button class="btn" id="addCommentBtn">Add Comment</button>
      </div>
      <div id="commentsList" style="margin-top: 12px;"></div>
    </div>
  </div>

  <script>
    // Application State
    const state = {
      currentTool: 'select',
      shapes: [],
      selectedShape: null,
      selectedShapes: [],
      isDrawing: false,
      startX: 0,
      startY: 0,
      currentPath: [],
      penMode: false,
      pencilMode: false,
      currentShape: 'rect',
      zoom: 1,
      panX: 0,
      panY: 0,
      isPanning: false,
      lastPanX: 0,
      lastPanY: 0,
      scalingShape: null,
      scaleStartX: 0,
      scaleStartY: 0,
      scaleCenterX: 0,
      scaleCenterY: 0,
      guiType: 'button',
      isDrawingSlice: false,
      sliceStartX: 0,
      sliceStartY: 0,
      isSelecting: false,
      selectionStartX: 0,
      selectionStartY: 0,
      isTransforming: false,
      transformHandle: null,
      transformStartX: 0,
      transformStartY: 0,
      transformStartShape: null,
      clipboard: []
    };

    // Canvas Setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Make canvas and state available to modules
    window.canvas = canvas;
    window.ctx = ctx;
    
    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight - 48 - 24; // Top bar + status bar
      canvas.style.width = canvas.width + 'px';
      canvas.style.height = canvas.height + 'px';
      redraw();
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Tool Selection
    const toolButtons = document.querySelectorAll('.tool-btn');
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const tool = btn.dataset.tool;
        if (tool === 'shape') {
          document.getElementById('shapeSubmenu').classList.toggle('visible');
          return;
        }
        selectTool(tool);
        document.getElementById('shapeSubmenu').classList.remove('visible');
      });
    });

    // Shape submenu
    document.querySelectorAll('.shape-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        state.currentShape = btn.dataset.shape;
        selectTool('shape');
        document.getElementById('shapeSubmenu').classList.remove('visible');
      });
    });

    function selectTool(tool) {
      state.currentTool = tool;
      toolButtons.forEach(b => b.classList.remove('active'));
      document.querySelector(`[data-tool="${tool}"]`)?.classList.add('active');
      
      // Update canvas cursor
      canvas.className = 'canvas ' + tool + '-mode';
      
      // Reset drawing states
      state.penMode = tool === 'pen';
      state.pencilMode = tool === 'pencil';
      state.currentPath = [];
      
      updateStatus(`Tool: ${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
    }

    // Keyboard Shortcuts
    const keyMap = {
      'v': 'select',
      'a': 'frame',
      'r': () => {
        if (state.currentTool === 'shape' && state.currentShape === 'rect') {
          state.currentShape = 'rounded';
        } else {
          selectTool('shape');
          state.currentShape = 'rect';
        }
      },
      'l': () => {
        if (state.currentTool === 'shape' && state.currentShape === 'line') {
          state.currentShape = 'arrow';
        } else {
          selectTool('shape');
          state.currentShape = 'line';
        }
      },
      'o': () => {
        const shapes = ['oval', 'triangle', 'polygon', 'star'];
        const idx = shapes.indexOf(state.currentShape);
        if (idx >= 0 && idx < shapes.length - 1) {
          state.currentShape = shapes[idx + 1];
        } else {
          selectTool('shape');
          state.currentShape = 'oval';
        }
      },
      't': 'text',
      'p': () => {
        if (state.currentTool === 'pen') {
          selectTool('pencil');
        } else {
          selectTool('pen');
        }
      },
      'm': 'image',
      'b': () => {
        if (state.currentTool === 'gui') {
          const types = ['button', 'input', 'checkbox', 'radio', 'slider', 'switch'];
          const currentIdx = types.indexOf(state.guiType || 'button');
          state.guiType = types[(currentIdx + 1) % types.length];
          updateStatus(`GUI type: ${state.guiType}`);
        } else {
          selectTool('gui');
          state.guiType = 'button';
        }
      },
      'd': () => {
        if (state.currentTool === 'gui') {
          state.guiType = 'input';
          updateStatus('GUI type: input');
        } else {
          selectTool('gui');
          state.guiType = 'input';
        }
      },
      'f': () => {
        if (state.currentTool === 'gui') {
          state.guiType = 'checkbox';
          updateStatus('GUI type: checkbox');
        } else {
          selectTool('gui');
          state.guiType = 'checkbox';
        }
      },
      'y': () => {
        if (state.currentTool === 'gui') {
          state.guiType = 'radio';
          updateStatus('GUI type: radio');
        } else {
          selectTool('gui');
          state.guiType = 'radio';
        }
      },
      'j': () => {
        if (state.currentTool === 'gui') {
          state.guiType = 'slider';
          updateStatus('GUI type: slider');
        } else {
          selectTool('gui');
          state.guiType = 'slider';
        }
      },
      'w': () => {
        if (state.currentTool === 'gui') {
          state.guiType = 'switch';
          updateStatus('GUI type: switch');
        } else {
          selectTool('gui');
          state.guiType = 'switch';
        }
      },
      'x': 'icon',
      'c': 'comment',
      'k': 'scale',
      'i': 'eyedropper',
      'h': 'hotspot',
      'e': 'slice',
      'q': 'avatar',
      's': 'component'
    };

    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      const key = e.key.toLowerCase();
      if (key === ' ' && state.currentTool !== 'hand') {
        e.preventDefault();
        selectTool('hand');
        state.isPanning = true;
      } else if (keyMap[key]) {
        e.preventDefault();
        if (typeof keyMap[key] === 'function') {
          keyMap[key]();
        } else {
          selectTool(keyMap[key]);
        }
      } else if (key === 'escape') {
        selectTool('select');
      } else if (key === 'z' && e.metaKey) {
        e.preventDefault();
        if (e.shiftKey) {
          redo();
        } else {
          undo();
        }
      } else if (key === 'b' && e.metaKey && e.shiftKey) {
        e.preventDefault();
        // Rotate Copies tool (‚åò‚áßB)
        if (state.selectedShape) {
          createRotateCopies(state.selectedShape);
        } else {
          updateStatus('Select a shape first to create rotated copies');
        }
      } else if (key === 'c' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Copy (Cmd/Ctrl+C)
        if (state.selectedShape || state.selectedShapes.length > 0) {
          copyShapes();
        }
      } else if (key === 'v' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Paste (Cmd/Ctrl+V)
        pasteShapes();
      } else if (key === 'd' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Duplicate (Cmd/Ctrl+D)
        if (state.selectedShape || state.selectedShapes.length > 0) {
          duplicateShapes();
        }
      } else if (key === 'g' && (e.metaKey || e.ctrlKey) && e.shiftKey) {
        e.preventDefault();
        // Ungroup (Cmd/Ctrl+Shift+G) - Check shift first (more specific)
        if (state.selectedShape && state.selectedShape._group) {
          ungroupShapes();
        }
      } else if (key === 'g' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Group (Cmd/Ctrl+G)
        if (state.selectedShapes.length > 1) {
          groupShapes();
        }
      } else if (key === 'delete' || key === 'backspace') {
        if (state.selectedShape || state.selectedShapes.length > 0) {
          deleteSelectedShapes();
        }
      } else if (key === '?' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Show keyboard help (Cmd+?)
        if (window.showKeyboardHelpModule) {
          window.showKeyboardHelpModule();
        }
      } else if ((key === '+' || key === '=') && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Zoom in
        state.zoom = Math.min(state.zoom * 1.2, 5);
        redraw();
      } else if (key === '-' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Zoom out
        state.zoom = Math.max(state.zoom / 1.2, 0.1);
        redraw();
      } else if (key === '0' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        // Reset zoom
        state.zoom = 1;
        redraw();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === ' ' && state.currentTool === 'hand') {
        selectTool('select');
        state.isPanning = false;
      }
    });

    // Mouse Events
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('mouseleave', handleMouseUp);
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const pos = getCanvasPos(e);
      const clickedShape = findShapeAt(pos.x, pos.y, state.shapes);
      
      if (clickedShape && (clickedShape === state.selectedShape || state.selectedShapes.includes(clickedShape))) {
        // Show context menu for selected shape
        if (window.showShapeContextMenuModule) {
          window.showShapeContextMenuModule(clickedShape, e.clientX, e.clientY, (action, shape) => {
            handleContextMenuAction(action, shape);
          });
        }
      } else {
        // Show context menu for canvas
        if (window.showCanvasContextMenuModule) {
          window.showCanvasContextMenuModule(e.clientX, e.clientY, (action) => {
            handleContextMenuAction(action, null);
          });
        }
      }
    });
    
    function handleContextMenuAction(action, shape) {
      switch (action) {
        case 'copy':
          if (shape || state.selectedShape) {
            copyShapes();
          }
          break;
        case 'paste':
          pasteShapes();
          break;
        case 'duplicate':
          if (shape || state.selectedShape) {
            duplicateShapes();
          }
          break;
        case 'delete':
          if (shape || state.selectedShape) {
            deleteSelectedShapes();
          }
          break;
        case 'bringToFront':
          if (shape) {
            const index = state.shapes.indexOf(shape);
            if (index > -1) {
              state.shapes.splice(index, 1);
              state.shapes.push(shape);
              updateLayersList();
              redraw();
            }
          }
          break;
        case 'sendToBack':
          if (shape) {
            const index = state.shapes.indexOf(shape);
            if (index > -1) {
              state.shapes.splice(index, 1);
              state.shapes.unshift(shape);
              updateLayersList();
              redraw();
            }
          }
          break;
        case 'group':
          if (state.selectedShapes.length > 1) {
            groupShapes();
          }
          break;
        case 'ungroup':
          if (shape && shape._group) {
            ungroupShapes();
          }
          break;
        case 'zoomIn':
          state.zoom = Math.min(state.zoom * 1.2, 5);
          redraw();
          break;
        case 'zoomOut':
          state.zoom = Math.max(state.zoom / 1.2, 0.1);
          redraw();
          break;
        case 'resetZoom':
          state.zoom = 1;
          redraw();
          break;
      }
    }

    // Coordinate conversion - Use module if available, otherwise fallback
    function getCanvasPos(e) {
      if (window.getCanvasPosUtil) {
        return window.getCanvasPosUtil(e, canvas, state);
      }
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) / state.zoom - state.panX,
        y: (e.clientY - rect.top) / state.zoom - state.panY
      };
    }

    function handleMouseDown(e) {
      const pos = getCanvasPos(e);
      state.startX = pos.x;
      state.startY = pos.y;
      state.isDrawing = true;

      if (state.currentTool === 'select') {
        // Check if clicking on a transform handle
        if (state.selectedShape) {
          const rect = canvas.getBoundingClientRect();
          const screenX = e.clientX - rect.left;
          const screenY = e.clientY - rect.top;
          const handle = getHandleAt(screenX, screenY, state.selectedShape);
          
          if (handle) {
            state.isTransforming = true;
            state.transformHandle = handle.type;
            state.transformStartX = pos.x;
            state.transformStartY = pos.y;
            state.transformStartShape = deepClone(state.selectedShape);
            canvas.style.cursor = handle.cursor;
            return;
          }
        }
        
        // Check if clicking on a shape
        const clickedShape = findShapeAt(pos.x, pos.y);
        if (clickedShape) {
          // Multi-select: Shift/Cmd/Ctrl + Click
          if (e.shiftKey || e.metaKey || e.ctrlKey) {
            if (state.selectedShapes.includes(clickedShape)) {
              // Deselect if already selected
              state.selectedShapes = state.selectedShapes.filter(s => s !== clickedShape);
              if (state.selectedShapes.length === 0) {
                state.selectedShape = null;
              } else {
                state.selectedShape = state.selectedShapes[0];
              }
            } else {
              // Add to selection
              state.selectedShapes.push(clickedShape);
              state.selectedShape = clickedShape;
            }
            updateLayersList();
            redraw();
          } else {
            // Single select
            selectShape(clickedShape);
            state.selectedShape = clickedShape;
            state.selectedShapes = [clickedShape];
            // Enable path editing if it's a pen/pencil path
            if (clickedShape.type === 'pen' || clickedShape.type === 'pencil') {
              enablePathEditing(clickedShape);
            }
          }
        } else {
          // Start selection box if not clicking on shape
          if (!e.shiftKey && !e.metaKey && !e.ctrlKey) {
            deselectShape();
            state.selectedShapes = [];
            state.editingPath = null;
            document.querySelectorAll('.bezier-handle, .bezier-line').forEach(el => el.remove());
            state.isSelecting = true;
            state.selectionStartX = pos.x;
            state.selectionStartY = pos.y;
          }
        }
      } else if (state.currentTool === 'hand') {
        state.isPanning = true;
        state.lastPanX = e.clientX;
        state.lastPanY = e.clientY;
      } else if (state.currentTool === 'pen' || state.currentTool === 'pencil') {
        const point = {
          x: pos.x,
          y: pos.y,
          handles: state.currentTool === 'pen' ? {
            in: { x: pos.x - 20, y: pos.y },
            out: { x: pos.x + 20, y: pos.y }
          } : null
        };
        state.currentPath = [point];
      } else if (state.currentTool === 'text') {
        createText(pos.x, pos.y);
      } else if (state.currentTool === 'image') {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = (ev) => {
          const file = ev.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              createImage(pos.x, pos.y, e.target.result);
            };
            reader.readAsDataURL(file);
          }
        };
        input.click();
      } else if (state.currentTool === 'eyedropper') {
        sampleColorAt(pos.x, pos.y);
      } else if (state.currentTool === 'scale') {
        // Scale tool: select shape and enter scale mode
        const clickedShape = findShapeAt(pos.x, pos.y);
        if (clickedShape) {
          selectShape(clickedShape);
          state.selectedShape = clickedShape;
          state.scalingShape = clickedShape;
          state.scaleStartX = clickedShape.width || 100;
          state.scaleStartY = clickedShape.height || 100;
          state.scaleCenterX = clickedShape.x + (clickedShape.width || 100) / 2;
          state.scaleCenterY = clickedShape.y + (clickedShape.height || 100) / 2;
        } else {
          deselectShape();
          state.scalingShape = null;
        }
      } else if (state.currentTool === 'icon') {
        // Icon tool: insert icon from asset library
        const allAssets = [...assetLibrary.icons, ...assetLibrary.shapes, ...assetLibrary.ui];
        const randomIcon = allAssets[Math.floor(Math.random() * allAssets.length)];
        createText(pos.x, pos.y, randomIcon);
        updateStatus('Icon inserted');
      } else if (state.currentTool === 'avatar') {
        // Avatar tool: insert circular image
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = (ev) => {
          const file = ev.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              createAvatar(pos.x, pos.y, e.target.result);
            };
            reader.readAsDataURL(file);
          }
        };
        input.click();
      } else if (state.currentTool === 'hotspot') {
        // Hotspot tool: create interactive hotspot
        createHotspot(pos.x, pos.y);
      } else if (state.currentTool === 'slice') {
        // Slice tool: create export region
        state.sliceStartX = pos.x;
        state.sliceStartY = pos.y;
        state.isDrawingSlice = true;
      } else if (state.currentTool === 'gui') {
        // GUI tool: create UI element (button by default, cycle with B/D/F/Y/J/W)
        const guiType = state.guiType || 'button';
        createGUIElement(pos.x, pos.y, guiType);
      }
    }

    function handleMouseMove(e) {
      const pos = getCanvasPos(e);
      
      if (state.currentTool === 'hand' && state.isPanning) {
        state.panX += (e.clientX - state.lastPanX) / state.zoom;
        state.panY += (e.clientY - state.lastPanY) / state.zoom;
        state.lastPanX = e.clientX;
        state.lastPanY = e.clientY;
        redraw();
        return;
      }

      if (state.currentTool === 'eyedropper') {
        sampleColorAt(pos.x, pos.y, true);
        return;
      }

      if (state.currentTool === 'scale' && state.scalingShape && state.isDrawing) {
        // Calculate scale based on distance from center
        const dx = pos.x - state.scaleCenterX;
        const dy = pos.y - state.scaleCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const startDistance = Math.sqrt(
          Math.pow(state.scaleStartX / 2, 2) + Math.pow(state.scaleStartY / 2, 2)
        );
        const scale = Math.max(0.1, distance / startDistance);
        
        state.scalingShape.width = state.scaleStartX * scale;
        state.scalingShape.height = state.scaleStartY * scale;
        state.scalingShape.x = state.scaleCenterX - state.scalingShape.width / 2;
        state.scalingShape.y = state.scaleCenterY - state.scalingShape.height / 2;
        
        // Update properties panel
        if (state.scalingShape.width !== undefined) {
          document.getElementById('width').value = Math.round(state.scalingShape.width);
        }
        if (state.scalingShape.height !== undefined) {
          document.getElementById('height').value = Math.round(state.scalingShape.height);
        }
        if (state.scalingShape.x !== undefined) {
          document.getElementById('posX').value = Math.round(state.scalingShape.x);
        }
        if (state.scalingShape.y !== undefined) {
          document.getElementById('posY').value = Math.round(state.scalingShape.y);
        }
        
        updateStatus(`Scale: ${Math.round(scale * 100)}%`);
        redraw();
        return;
      }

      if (state.currentTool === 'slice' && state.isDrawingSlice) {
        // Draw slice preview
        redraw();
        drawSlicePreview(state.sliceStartX, state.sliceStartY, pos.x, pos.y);
        return;
      }

      if (state.currentTool === 'select' && state.isSelecting) {
        // Draw selection box
        redraw();
        drawSelectionBox(state.selectionStartX, state.selectionStartY, pos.x, pos.y);
        return;
      }

      if (state.currentTool === 'select' && state.isTransforming && state.selectedShape) {
        applyTransform(state.transformHandle, pos.x, pos.y);
        redraw();
        return;
      }

      // Update cursor for transform handles
      if (state.currentTool === 'select' && state.selectedShape && !state.isTransforming && !state.isSelecting) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const handle = getHandleAt(screenX, screenY, state.selectedShape);
        canvas.style.cursor = handle ? handle.cursor : 'default';
      }

      if (!state.isDrawing) return;

      if (state.currentTool === 'pen' || state.currentTool === 'pencil') {
        const point = {
          x: pos.x,
          y: pos.y,
          handles: state.currentTool === 'pen' ? {
            in: { x: pos.x - 20, y: pos.y },
            out: { x: pos.x + 20, y: pos.y }
          } : null
        };
        state.currentPath.push(point);
        redraw();
        drawCurrentPath();
      } else if (state.currentTool !== 'select' && state.currentTool !== 'text' && state.currentTool !== 'eyedropper' && state.currentTool !== 'scale' && state.currentTool !== 'slice' && state.currentTool !== 'icon' && state.currentTool !== 'hotspot' && state.currentTool !== 'avatar' && state.currentTool !== 'gui') {
        redraw();
        drawPreview(pos.x, pos.y);
      }
    }

    function handleMouseUp(e) {
      if (!state.isDrawing) return;
      
      const pos = getCanvasPos(e);
      state.isDrawing = false;

      if (state.currentTool === 'scale' && state.scalingShape) {
        saveState();
        state.scalingShape = null;
        updateStatus('Scale complete');
        return;
      }

      if (state.currentTool === 'slice' && state.isDrawingSlice) {
        createSlice(state.sliceStartX, state.sliceStartY, pos.x - state.sliceStartX, pos.y - state.sliceStartY);
        state.isDrawingSlice = false;
        redraw();
        return;
      }

      if (state.currentTool === 'select' && state.isSelecting) {
        // Complete selection box
        const minX = Math.min(state.selectionStartX, pos.x);
        const maxX = Math.max(state.selectionStartX, pos.x);
        const minY = Math.min(state.selectionStartY, pos.y);
        const maxY = Math.max(state.selectionStartY, pos.y);
        
        const selected = state.shapes.filter(shape => {
          if (shape.visible === false) return false;
          const shapeRight = shape.x + (shape.width || 0);
          const shapeBottom = shape.y + (shape.height || 0);
          return shape.x >= minX && shapeRight <= maxX && shape.y >= minY && shapeBottom <= maxY;
        });
        
        if (selected.length > 0) {
          state.selectedShapes = selected;
          state.selectedShape = selected[0];
          updateLayersList();
        }
        state.isSelecting = false;
        redraw();
        return;
      }

      if (state.currentTool === 'select' && state.isTransforming) {
        saveState();
        state.isTransforming = false;
        state.transformHandle = null;
        state.transformStartShape = null;
        canvas.style.cursor = 'default';
        updatePropertiesPanel(state.selectedShape);
        redraw();
        return;
      }

      if (state.currentTool === 'pen' || state.currentTool === 'pencil') {
        if (state.currentPath.length > 1) {
          createPath(state.currentPath, state.currentTool === 'pencil');
        }
        state.currentPath = [];
      } else if (state.currentTool === 'frame') {
        createFrame(state.startX, state.startY, pos.x - state.startX, pos.y - state.startY);
      } else if (state.currentTool === 'shape') {
        createShape(state.currentShape, state.startX, state.startY, pos.x - state.startX, pos.y - state.startY);
      }
      
      redraw();
      state.isPanning = false;
    }

    // Shape Creation
    function createShape(type, x, y, w, h) {
      saveState();
      const shape = {
        id: Date.now(),
        type: type,
        x: Math.min(x, x + w),
        y: Math.min(y, y + h),
        width: Math.abs(w),
        height: Math.abs(h),
        fill: document.getElementById('fillColor').value,
        stroke: document.getElementById('strokeColor').value,
        strokeWidth: parseInt(document.getElementById('strokeWidth').value),
        opacity: parseFloat(document.getElementById('opacity').value),
        rotation: 0
      };
      state.shapes.push(shape);
      updateLayersList();
      selectShape(shape);
    }

    function createFrame(x, y, w, h) {
      saveState();
      const frame = {
        id: Date.now(),
        type: 'frame',
        x: Math.min(x, x + w),
        y: Math.min(y, y + h),
        width: Math.abs(w),
        height: Math.abs(h),
        fill: 'transparent',
        stroke: '#4a9eff',
        strokeWidth: 2,
        opacity: 1,
        rotation: 0
      };
      state.shapes.push(frame);
      updateLayersList();
      selectShape(frame);
    }

    function createText(x, y, text) {
      if (!text) {
        text = prompt('Enter text:');
      }
      if (text) {
        saveState();
        const shape = {
          id: Date.now(),
          type: 'text',
          x: x,
          y: y,
          text: text,
          fontSize: 16,
          fill: document.getElementById('fillColor').value,
          opacity: 1,
          rotation: 0
        };
        state.shapes.push(shape);
        updateLayersList();
        selectShape(shape);
        redraw();
      }
    }

    function createImage(x, y, src) {
      saveState();
      const img = new Image();
      img.onload = () => {
        const shape = {
          id: Date.now(),
          type: 'image',
          x: x,
          y: y,
          width: img.width,
          height: img.height,
          src: src,
          opacity: 1,
          rotation: 0
        };
        state.shapes.push(shape);
        updateLayersList();
        selectShape(shape);
        redraw();
      };
      img.src = src;
    }

    function createAvatar(x, y, src) {
      saveState();
      const img = new Image();
      img.onload = () => {
        const size = Math.min(img.width, img.height, 100);
        const shape = {
          id: Date.now(),
          type: 'avatar',
          x: x,
          y: y,
          width: size,
          height: size,
          src: src,
          opacity: 1,
          rotation: 0
        };
        state.shapes.push(shape);
        updateLayersList();
        selectShape(shape);
        redraw();
      };
      img.src = src;
    }

    function createHotspot(x, y) {
      saveState();
      const shape = {
        id: Date.now(),
        type: 'hotspot',
        x: x - 15,
        y: y - 15,
        width: 30,
        height: 30,
        fill: 'rgba(74, 158, 255, 0.3)',
        stroke: '#4a9eff',
        strokeWidth: 2,
        opacity: 1,
        rotation: 0
      };
      state.shapes.push(shape);
      updateLayersList();
      selectShape(shape);
      redraw();
      updateStatus('Hotspot created');
    }

    function createGUIElement(x, y, type) {
      saveState();
      let shape;
      const defaultWidth = 120;
      const defaultHeight = 40;
      
      switch(type) {
        case 'button':
          shape = {
            id: Date.now(),
            type: 'gui',
            guiType: 'button',
            x: x,
            y: y,
            width: defaultWidth,
            height: defaultHeight,
            fill: '#4a9eff',
            stroke: '#3a8eef',
            strokeWidth: 1,
            opacity: 1,
            rotation: 0,
            text: 'Button'
          };
          break;
        case 'input':
          shape = {
            id: Date.now(),
            type: 'gui',
            guiType: 'input',
            x: x,
            y: y,
            width: defaultWidth,
            height: defaultHeight,
            fill: '#ffffff',
            stroke: '#cccccc',
            strokeWidth: 1,
            opacity: 1,
            rotation: 0,
            text: 'Input text...'
          };
          break;
        case 'checkbox':
          shape = {
            id: Date.now(),
            type: 'gui',
            guiType: 'checkbox',
            x: x,
            y: y,
            width: 20,
            height: 20,
            fill: '#ffffff',
            stroke: '#cccccc',
            strokeWidth: 1,
            opacity: 1,
            rotation: 0
          };
          break;
        case 'radio':
          shape = {
            id: Date.now(),
            type: 'gui',
            guiType: 'radio',
            x: x,
            y: y,
            width: 20,
            height: 20,
            fill: '#ffffff',
            stroke: '#cccccc',
            strokeWidth: 1,
            opacity: 1,
            rotation: 0
          };
          break;
        case 'slider':
          shape = {
            id: Date.now(),
            type: 'gui',
            guiType: 'slider',
            x: x,
            y: y,
            width: defaultWidth,
            height: 6,
            fill: '#4a9eff',
            stroke: '#cccccc',
            strokeWidth: 1,
            opacity: 1,
            rotation: 0
          };
          break;
        case 'switch':
          shape = {
            id: Date.now(),
            type: 'gui',
            guiType: 'switch',
            x: x,
            y: y,
            width: 50,
            height: 30,
            fill: '#4a9eff',
            stroke: '#3a8eef',
            strokeWidth: 1,
            opacity: 1,
            rotation: 0
          };
          break;
        default:
          shape = {
            id: Date.now(),
            type: 'gui',
            guiType: 'button',
            x: x,
            y: y,
            width: defaultWidth,
            height: defaultHeight,
            fill: '#4a9eff',
            stroke: '#3a8eef',
            strokeWidth: 1,
            opacity: 1,
            rotation: 0,
            text: 'Button'
          };
      }
      
      state.shapes.push(shape);
      updateLayersList();
      selectShape(shape);
      redraw();
      updateStatus(`GUI ${type} created`);
    }

    function createRotateCopies(shape) {
      saveState();
      const copies = 8;
      const radius = Math.max(shape.width || 100, shape.height || 100) * 1.5;
      const centerX = shape.x + (shape.width || 100) / 2;
      const centerY = shape.y + (shape.height || 100) / 2;
      
      for (let i = 1; i < copies; i++) {
        const angle = (i * 2 * Math.PI) / copies;
        const offsetX = Math.cos(angle) * radius;
        const offsetY = Math.sin(angle) * radius;
        
        const copy = deepClone(shape);
        copy.id = Date.now() + i;
        copy.x = centerX + offsetX - (copy.width || 100) / 2;
        copy.y = centerY + offsetY - (copy.height || 100) / 2;
        copy.rotation = (copy.rotation || 0) + (i * 360) / copies;
        
        state.shapes.push(copy);
      }
      
      updateLayersList();
      redraw();
      updateStatus(`Created ${copies - 1} rotated copies`);
    }

    function createPath(points, isPencil) {
      saveState();
      const shape = {
        id: Date.now(),
        type: isPencil ? 'pencil' : 'pen',
        points: [...points],
        stroke: document.getElementById('strokeColor').value,
        strokeWidth: isPencil ? 1 : parseInt(document.getElementById('strokeWidth').value),
        opacity: parseFloat(document.getElementById('opacity').value),
        rotation: 0
      };
      state.shapes.push(shape);
      updateLayersList();
      selectShape(shape);
    }

    // Drawing Functions
    function drawShape(shape) {
      ctx.save();
      ctx.globalAlpha = shape.opacity || 1;
      
      // Apply blur effect if present
      if (shape.blur && shape.blur > 0) {
        ctx.filter = `blur(${shape.blur}px)`;
      }
      
      // Apply shadow if present
      if (shape.shadow) {
        ctx.shadowColor = shape.shadowColor || 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = shape.shadowBlur || 10;
        ctx.shadowOffsetX = shape.shadowOffsetX || 2;
        ctx.shadowOffsetY = shape.shadowOffsetY || 2;
      }
      
      if (shape.rotation) {
        ctx.translate(shape.x + shape.width / 2, shape.y + shape.height / 2);
        ctx.rotate((shape.rotation * Math.PI) / 180);
        ctx.translate(-(shape.x + shape.width / 2), -(shape.y + shape.height / 2));
      }

      // Setup fill (gradient or solid)
      if (shape.fillType === 'gradient' && shape.gradientStart && shape.gradientEnd) {
        let gradient;
        const x0 = shape.x;
        const y0 = shape.y;
        const x1 = shape.x + (shape.width || 0);
        const y1 = shape.y + (shape.height || 0);
        
        if (shape.gradientDirection === 'horizontal') {
          gradient = ctx.createLinearGradient(x0, y0, x1, y0);
        } else if (shape.gradientDirection === 'vertical') {
          gradient = ctx.createLinearGradient(x0, y0, x0, y1);
        } else { // diagonal
          gradient = ctx.createLinearGradient(x0, y0, x1, y1);
        }
        gradient.addColorStop(0, shape.gradientStart);
        gradient.addColorStop(1, shape.gradientEnd);
        ctx.fillStyle = gradient;
      } else {
        ctx.fillStyle = shape.fill || 'transparent';
      }
      
      ctx.strokeStyle = shape.stroke || '#000';
      ctx.lineWidth = shape.strokeWidth || 0;

      switch (shape.type) {
        case 'rect':
          ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
          if (shape.strokeWidth > 0) ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
          break;
        case 'rounded':
          drawRoundedRect(shape.x, shape.y, shape.width, shape.height, 8);
          break;
        case 'line':
          ctx.beginPath();
          ctx.moveTo(shape.x, shape.y);
          ctx.lineTo(shape.x + shape.width, shape.y + shape.height);
          ctx.stroke();
          break;
        case 'arrow':
          drawArrow(shape.x, shape.y, shape.x + shape.width, shape.y + shape.height);
          break;
        case 'oval':
          ctx.beginPath();
          ctx.ellipse(shape.x + shape.width / 2, shape.y + shape.height / 2, 
                     Math.abs(shape.width) / 2, Math.abs(shape.height) / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          if (shape.strokeWidth > 0) ctx.stroke();
          break;
        case 'triangle':
          drawTriangle(shape.x, shape.y, shape.width, shape.height);
          break;
        case 'polygon':
          drawPolygon(shape.x + shape.width / 2, shape.y + shape.height / 2, 
                     Math.min(shape.width, shape.height) / 2, 6);
          break;
        case 'star':
          drawStar(shape.x + shape.width / 2, shape.y + shape.height / 2, 
                   Math.min(shape.width, shape.height) / 2, 5);
          break;
        case 'frame':
          ctx.strokeStyle = shape.stroke;
          ctx.lineWidth = shape.strokeWidth;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
          ctx.setLineDash([]);
          break;
        case 'text':
          ctx.fillStyle = shape.fill || '#000000';
          const fontSize = shape.fontSize || 16;
          const fontWeight = shape.fontWeight || 'normal';
          const fontStyle = shape.fontStyle || 'normal';
          ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px sans-serif`;
          ctx.textAlign = shape.textAlign || 'left';
          ctx.textBaseline = 'top';
          ctx.fillText(shape.text || '', shape.x, shape.y);
          break;
        case 'image':
          if (shape._img && shape._img.complete) {
            ctx.drawImage(shape._img, shape.x, shape.y, shape.width, shape.height);
          } else {
            const img = new Image();
            img.onload = () => {
              shape._img = img;
              redraw();
            };
            img.src = shape.src;
          }
          break;
        case 'pen':
        case 'pencil':
          if (shape.points && shape.points.length > 1) {
            ctx.strokeStyle = shape.stroke;
            ctx.lineWidth = shape.strokeWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            
            const p0 = shape.points[0];
            ctx.moveTo(p0.x, p0.y);
            
            for (let i = 1; i < shape.points.length; i++) {
              const p1 = shape.points[i];
              const pPrev = shape.points[i - 1];
              
              if (pPrev.handles && pPrev.handles.out && p1.handles && p1.handles.in) {
                // B√©zier curve
                ctx.bezierCurveTo(
                  pPrev.handles.out.x, pPrev.handles.out.y,
                  p1.handles.in.x, p1.handles.in.y,
                  p1.x, p1.y
                );
              } else {
                ctx.lineTo(p1.x, p1.y);
              }
            }
            
            ctx.stroke();
          }
          break;
        case 'avatar':
          if (shape._img && shape._img.complete) {
            ctx.beginPath();
            ctx.arc(shape.x + shape.width / 2, shape.y + shape.height / 2, shape.width / 2, 0, Math.PI * 2);
            ctx.save();
            ctx.clip();
            ctx.drawImage(shape._img, shape.x, shape.y, shape.width, shape.height);
            ctx.restore();
            // Draw border
            ctx.strokeStyle = shape.stroke || '#cccccc';
            ctx.lineWidth = shape.strokeWidth || 1;
            ctx.beginPath();
            ctx.arc(shape.x + shape.width / 2, shape.y + shape.height / 2, shape.width / 2, 0, Math.PI * 2);
            ctx.stroke();
          } else {
            const img = new Image();
            img.onload = () => {
              shape._img = img;
              redraw();
            };
            img.src = shape.src;
          }
          break;
        case 'hotspot':
          ctx.fillStyle = shape.fill;
          ctx.strokeStyle = shape.stroke;
          ctx.lineWidth = shape.strokeWidth;
          ctx.beginPath();
          ctx.arc(shape.x + shape.width / 2, shape.y + shape.height / 2, shape.width / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          // Draw hotspot icon
          ctx.fillStyle = shape.stroke;
          ctx.beginPath();
          ctx.arc(shape.x + shape.width / 2, shape.y + shape.height / 2, 4, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'gui':
          ctx.fillStyle = shape.fill;
          ctx.strokeStyle = shape.stroke;
          ctx.lineWidth = shape.strokeWidth;
          if (shape.guiType === 'radio') {
            ctx.beginPath();
            ctx.arc(shape.x + shape.width / 2, shape.y + shape.height / 2, shape.width / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          } else if (shape.guiType === 'checkbox') {
            ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
            ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
          } else {
            ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
            ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
            if (shape.text) {
              ctx.fillStyle = shape.guiType === 'button' ? '#ffffff' : '#000000';
              ctx.font = '14px sans-serif';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(shape.text, shape.x + shape.width / 2, shape.y + shape.height / 2);
            }
          }
          break;
        case 'slice':
          ctx.strokeStyle = '#ff6b6b';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
          ctx.setLineDash([]);
          // Draw slice label
          ctx.fillStyle = '#ff6b6b';
          ctx.font = '12px sans-serif';
          ctx.fillText('Slice', shape.x + 5, shape.y - 5);
          break;
      }
      
      // Reset filters and shadows before restore
      ctx.filter = 'none';
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      
      ctx.restore();
    }

    function drawRoundedRect(x, y, w, h, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
      if (ctx.lineWidth > 0) ctx.stroke();
    }

    function drawArrow(x1, y1, x2, y2) {
      const angle = Math.atan2(y2 - y1, x2 - x1);
      const headlen = 15;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
      ctx.stroke();
    }

    function drawTriangle(x, y, w, h) {
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y);
      ctx.lineTo(x + w, y + h);
      ctx.lineTo(x, y + h);
      ctx.closePath();
      ctx.fill();
      if (ctx.lineWidth > 0) ctx.stroke();
    }

    function drawPolygon(x, y, radius, sides) {
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
        const px = x + radius * Math.cos(angle);
        const py = y + radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      if (ctx.lineWidth > 0) ctx.stroke();
    }

    function drawStar(x, y, radius, points) {
      ctx.beginPath();
      for (let i = 0; i < points * 2; i++) {
        const angle = (i * Math.PI) / points - Math.PI / 2;
        const r = i % 2 === 0 ? radius : radius * 0.5;
        const px = x + r * Math.cos(angle);
        const py = y + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      if (ctx.lineWidth > 0) ctx.stroke();
    }

    function drawPreview(x, y) {
      const w = x - state.startX;
      const h = y - state.startY;
      
      ctx.save();
      ctx.strokeStyle = '#4a9eff';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      
      switch (state.currentTool) {
        case 'frame':
          ctx.strokeRect(state.startX, state.startY, w, h);
          break;
        case 'shape':
          switch (state.currentShape) {
            case 'rect':
              ctx.strokeRect(state.startX, state.startY, w, h);
              break;
            case 'oval':
              ctx.beginPath();
              ctx.ellipse(state.startX + w / 2, state.startY + h / 2, 
                         Math.abs(w) / 2, Math.abs(h) / 2, 0, 0, Math.PI * 2);
              ctx.stroke();
              break;
          }
          break;
      }
      
      ctx.setLineDash([]);
      ctx.restore();
    }

    function drawCurrentPath() {
      if (state.currentPath.length < 2) return;
      ctx.save();
      ctx.strokeStyle = document.getElementById('strokeColor').value;
      ctx.lineWidth = state.currentTool === 'pencil' ? 1 : parseInt(document.getElementById('strokeWidth').value);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.beginPath();
      ctx.moveTo(state.currentPath[0].x, state.currentPath[0].y);
      for (let i = 1; i < state.currentPath.length; i++) {
        ctx.lineTo(state.currentPath[i].x, state.currentPath[i].y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawSlicePreview(x1, y1, x2, y2) {
      ctx.save();
      ctx.strokeStyle = '#ff6b6b';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(
        Math.min(x1, x2),
        Math.min(y1, y2),
        Math.abs(x2 - x1),
        Math.abs(y2 - y1)
      );
      ctx.setLineDash([]);
      ctx.restore();
    }

    function createSlice(x, y, w, h) {
      saveState();
      const shape = {
        id: Date.now(),
        type: 'slice',
        x: Math.min(x, x + w),
        y: Math.min(y, y + h),
        width: Math.abs(w),
        height: Math.abs(h),
        fill: 'transparent',
        stroke: '#ff6b6b',
        strokeWidth: 2,
        opacity: 1,
        rotation: 0
      };
      state.shapes.push(shape);
      updateLayersList();
      selectShape(shape);
      updateStatus('Slice created');
    }

    // Throttled redraw using requestAnimationFrame for smooth 60fps
    let redrawRafId = null;
    let pendingRedraw = false;
    
    function redraw() {
      if (redrawRafId !== null) {
        pendingRedraw = true;
        return;
      }
      
      pendingRedraw = false;
      redrawRafId = requestAnimationFrame(() => {
        redrawRafId = null;
        performRedraw();
        
        // If redraw was called again during this frame, schedule another
        if (pendingRedraw) {
          redraw();
        }
      });
    }
    
    function performRedraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.scale(state.zoom, state.zoom);
      ctx.translate(state.panX, state.panY);
      
      // Draw grid - Use module if available, otherwise fallback
      if (window.drawGridModule) {
        window.drawGridModule(ctx, canvas, state);
      } else {
        drawGrid();
      }
      
      // Draw all shapes
      state.shapes.forEach(shape => {
        if (shape.visible !== false) {
          if (window.drawShapeModule) {
            window.drawShapeModule(ctx, shape);
          } else {
            drawShape(shape);
          }
        }
      });
      
      // Draw selection
      if (state.selectedShapes.length > 0) {
        state.selectedShapes.forEach(shape => {
          if (window.drawSelectionModule) {
            window.drawSelectionModule(ctx, shape, state, state.currentTool);
          } else {
            drawSelection(shape);
          }
        });
      } else if (state.selectedShape) {
        if (window.drawSelectionModule) {
          window.drawSelectionModule(ctx, state.selectedShape, state, state.currentTool);
        } else {
          drawSelection(state.selectedShape);
        }
      }
      
      ctx.restore();
      
      // Update zoom level display
      const zoomLevel = document.getElementById('zoom-level');
      if (zoomLevel) {
        zoomLevel.textContent = Math.round(state.zoom * 100) + '%';
      }
    }

    // Fallback grid drawing function
    function drawGrid() {
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      const gridSize = 20;
      const startX = Math.floor(-state.panX / gridSize) * gridSize;
      const startY = Math.floor(-state.panY / gridSize) * gridSize;
      
      for (let x = startX; x < canvas.width / state.zoom + state.panX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, -state.panY);
        ctx.lineTo(x, canvas.height / state.zoom - state.panY);
        ctx.stroke();
      }
      
      for (let y = startY; y < canvas.height / state.zoom + state.panY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(-state.panX, y);
        ctx.lineTo(canvas.width / state.zoom - state.panX, y);
        ctx.stroke();
      }
    }
    
    // Make redraw available to modules
    window.redraw = redraw;
    window.state = state;

    // Use module if available, otherwise fallback
    function getTransformHandles(shape) {
      if (window.getTransformHandlesModule) {
        return window.getTransformHandlesModule(shape);
      }
      // Fallback implementation
      if (!shape || (shape.width === undefined && shape.height === undefined)) return [];
      
      const w = shape.width || 0;
      const h = shape.height || 0;
      const x = shape.x;
      const y = shape.y;
      
      return [
        { type: 'nw', x: x - 2, y: y - 2, cursor: 'nwse-resize' },      // Top-left
        { type: 'ne', x: x + w + 2, y: y - 2, cursor: 'nesw-resize' },  // Top-right
        { type: 'sw', x: x - 2, y: y + h + 2, cursor: 'nesw-resize' }, // Bottom-left
        { type: 'se', x: x + w + 2, y: y + h + 2, cursor: 'nwse-resize' }, // Bottom-right
        { type: 'n', x: x + w / 2, y: y - 2, cursor: 'ns-resize' },     // Top
        { type: 's', x: x + w / 2, y: y + h + 2, cursor: 'ns-resize' }, // Bottom
        { type: 'w', x: x - 2, y: y + h / 2, cursor: 'ew-resize' },     // Left
        { type: 'e', x: x + w + 2, y: y + h / 2, cursor: 'ew-resize' }, // Right
        { type: 'rotate', x: x + w / 2, y: y - 30, cursor: 'grab' }     // Rotate handle
      ];
    }

    function getHandleAt(x, y, shape) {
      if (window.getHandleAtModule) {
        return window.getHandleAtModule(x, y, shape, state);
      }
      // Fallback implementation
      const handles = getTransformHandles(shape);
      const handleSize = 6;
      
      for (const handle of handles) {
        const screenX = (handle.x + state.panX) * state.zoom;
        const screenY = (handle.y + state.panY) * state.zoom;
        const dx = x - screenX;
        const dy = y - screenY;
        if (Math.abs(dx) < handleSize && Math.abs(dy) < handleSize) {
          return handle;
        }
      }
      return null;
    }

    function drawSelection(shape) {
      ctx.save();
      ctx.strokeStyle = '#4a9eff';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(shape.x - 2, shape.y - 2, (shape.width || 0) + 4, (shape.height || 0) + 4);
      ctx.setLineDash([]);
      
      // Draw transform handles if select tool is active
      if (state.currentTool === 'select' && shape === state.selectedShape && !state.isSelecting) {
        const handles = getTransformHandles(shape);
        
        // Draw rotation handle line
        if (handles.length > 0) {
          const rotateHandle = handles[handles.length - 1];
          const centerX = shape.x + (shape.width || 0) / 2;
          const centerY = shape.y + (shape.height || 0) / 2;
          
          ctx.strokeStyle = '#4a9eff';
          ctx.lineWidth = 1;
          ctx.setLineDash([2, 2]);
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(rotateHandle.x, rotateHandle.y);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw all handles
        handles.forEach(handle => {
          ctx.fillStyle = handle.type === 'rotate' ? '#ffa500' : '#4a9eff';
          ctx.beginPath();
          if (handle.type === 'rotate') {
            ctx.arc(handle.x, handle.y, 6, 0, Math.PI * 2);
          } else {
            ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);
          }
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.stroke();
        });
      }
      
      // Draw scale handle if scale tool is active
      if (state.currentTool === 'scale' && shape === state.selectedShape) {
        const centerX = shape.x + (shape.width || 0) / 2;
        const centerY = shape.y + (shape.height || 0) / 2;
        const handleX = shape.x + (shape.width || 0);
        const handleY = shape.y;
        
        // Draw line from center to handle
        ctx.strokeStyle = '#ffa500';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(handleX, handleY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw scale handle
        ctx.fillStyle = '#ffa500';
        ctx.beginPath();
        ctx.arc(handleX, handleY, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      ctx.restore();
    }

    function drawSelectionBox(x1, y1, x2, y2) {
      ctx.save();
      ctx.strokeStyle = '#4a9eff';
      ctx.fillStyle = 'rgba(74, 158, 255, 0.1)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      const minX = Math.min(x1, x2);
      const minY = Math.min(y1, y2);
      const width = Math.abs(x2 - x1);
      const height = Math.abs(y2 - y1);
      ctx.fillRect(minX, minY, width, height);
      ctx.strokeRect(minX, minY, width, height);
      ctx.setLineDash([]);
      ctx.restore();
    }

    function applyTransform(handleType, x, y) {
      if (!state.selectedShape || !state.transformStartShape) return;
      
      if (window.applyTransformModule) {
        // Use module but need to calculate rotation differently
        const shape = state.selectedShape;
        const start = state.transformStartShape;
        
        if (handleType === 'rotate') {
          const centerX = start.x + (start.width || 0) / 2;
          const centerY = start.y + (start.height || 0) / 2;
          const startAngle = Math.atan2(state.transformStartY - centerY, state.transformStartX - centerX);
          const currentAngle = Math.atan2(y - centerY, x - centerX);
          const rotation = (currentAngle - startAngle) * (180 / Math.PI);
          shape.rotation = (start.rotation || 0) + rotation;
          document.getElementById('rotation').value = shape.rotation;
          document.getElementById('rotationValue').textContent = Math.round(shape.rotation) + '¬∞';
          // Module doesn't handle rotation, so skip it for rotate
        } else {
          // Create a temporary transform start shape with current position
          const tempStart = { ...start };
          tempStart.x = state.transformStartX - (tempStart.width || 0) / 2;
          tempStart.y = state.transformStartY - (tempStart.height || 0) / 2;
          window.applyTransformModule(shape, handleType, x, y, tempStart);
          // Update properties panel
          if (shape.x !== undefined) document.getElementById('posX').value = Math.round(shape.x);
          if (shape.y !== undefined) document.getElementById('posY').value = Math.round(shape.y);
          if (shape.width !== undefined) document.getElementById('width').value = Math.round(shape.width);
          if (shape.height !== undefined) document.getElementById('height').value = Math.round(shape.height);
        }
        return;
      }
      
      // Fallback implementation
      const shape = state.selectedShape;
      const start = state.transformStartShape;
      const dx = x - state.transformStartX;
      const dy = y - state.transformStartY;
      
      if (handleType === 'rotate') {
        const centerX = start.x + (start.width || 0) / 2;
        const centerY = start.y + (start.height || 0) / 2;
        const startAngle = Math.atan2(state.transformStartY - centerY, state.transformStartX - centerX);
        const currentAngle = Math.atan2(y - centerY, x - centerX);
        const rotation = (currentAngle - startAngle) * (180 / Math.PI);
        shape.rotation = (start.rotation || 0) + rotation;
        document.getElementById('rotation').value = shape.rotation;
        document.getElementById('rotationValue').textContent = Math.round(shape.rotation) + '¬∞';
      } else {
        // Resize handles
        const startX = start.x;
        const startY = start.y;
        const startW = start.width || 0;
        const startH = start.height || 0;
        
        switch(handleType) {
          case 'nw':
            shape.x = startX + dx;
            shape.y = startY + dy;
            shape.width = startW - dx;
            shape.height = startH - dy;
            break;
          case 'ne':
            shape.y = startY + dy;
            shape.width = startW + dx;
            shape.height = startH - dy;
            break;
          case 'sw':
            shape.x = startX + dx;
            shape.width = startW - dx;
            shape.height = startH + dy;
            break;
          case 'se':
            shape.width = startW + dx;
            shape.height = startH + dy;
            break;
          case 'n':
            shape.y = startY + dy;
            shape.height = startH - dy;
            break;
          case 's':
            shape.height = startH + dy;
            break;
          case 'w':
            shape.x = startX + dx;
            shape.width = startW - dx;
            break;
          case 'e':
            shape.width = startW + dx;
            break;
        }
        
        // Ensure minimum size
        if (shape.width < 5) shape.width = 5;
        if (shape.height < 5) shape.height = 5;
        
        // Update properties panel
        if (shape.x !== undefined) document.getElementById('posX').value = Math.round(shape.x);
        if (shape.y !== undefined) document.getElementById('posY').value = Math.round(shape.y);
        if (shape.width !== undefined) document.getElementById('width').value = Math.round(shape.width);
        if (shape.height !== undefined) document.getElementById('height').value = Math.round(shape.height);
      }
    }

    // Eyedropper Tool
    function sampleColorAt(x, y, preview = false) {
      // Redraw everything to canvas first to sample from
      redraw();
      
      // Convert canvas coordinates to pixel coordinates
      const pixelX = Math.round((x + state.panX) * state.zoom);
      const pixelY = Math.round((y + state.panY) * state.zoom);
      
      // Get image data at clicked position
      try {
        const imageData = ctx.getImageData(pixelX, pixelY, 1, 1);
        const pixel = imageData.data;
        const r = pixel[0];
        const g = pixel[1];
        const b = pixel[2];
        const a = pixel[3];
        
        // Convert to hex color
        const hex = rgbToHex(r, g, b);
        
        if (preview) {
          // Just show preview in status
          updateStatus(`Color: ${hex} (R:${r} G:${g} B:${b})`);
        } else {
          // Apply color to selected shape or properties panel
          if (state.selectedShape) {
            // Check if user wants fill or stroke (default to fill)
            // For now, apply to fill
            state.selectedShape.fill = hex;
            document.getElementById('fillColor').value = hex;
            updateStatus(`Applied fill color: ${hex}`);
          } else {
            // Update properties panel default
            document.getElementById('fillColor').value = hex;
            updateStatus(`Set fill color: ${hex}`);
          }
          redraw();
        }
      } catch (e) {
        console.error('Error sampling color:', e);
        updateStatus('Error sampling color');
      }
    }

    // Use module function if available, otherwise fallback
    function rgbToHex(r, g, b) {
      if (window.rgbToHex) return window.rgbToHex(r, g, b);
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    // Selection - Use module if available, otherwise fallback
    function findShapeAt(x, y) {
      if (window.findShapeAtModule) {
        return window.findShapeAtModule(x, y, state.shapes);
      }
      // Fallback implementation
      for (let i = state.shapes.length - 1; i >= 0; i--) {
        const shape = state.shapes[i];
        if (shape.visible === false) continue;
        
        if (shape.type === 'text') {
          if (x >= shape.x && x <= shape.x + 100 && y >= shape.y - 20 && y <= shape.y) {
            return shape;
          }
        } else if (shape.type === 'pen' || shape.type === 'pencil') {
          // Simple point-in-path check
          for (let p of shape.points || []) {
            if (Math.abs(p.x - x) < 5 && Math.abs(p.y - y) < 5) return shape;
          }
        } else if (shape.type === 'hotspot' || shape.type === 'avatar') {
          // Circular shapes
          const centerX = shape.x + (shape.width || 0) / 2;
          const centerY = shape.y + (shape.height || 0) / 2;
          const radius = (shape.width || 0) / 2;
          const dx = x - centerX;
          const dy = y - centerY;
          if (dx * dx + dy * dy <= radius * radius) {
            return shape;
          }
        } else if (x >= shape.x && x <= shape.x + (shape.width || 0) &&
                   y >= shape.y && y <= shape.y + (shape.height || 0)) {
          return shape;
        }
      }
      return null;
    }

    function selectShape(shape) {
      state.selectedShape = shape;
      updatePropertiesPanel(shape);
      updateLayersList();
      redraw();
    }

    function deselectShape() {
      state.selectedShape = null;
      updatePropertiesPanel(null);
      updateLayersList();
      redraw();
    }

    // Properties Panel
    function updatePropertiesPanel(shape) {
      // Hide text formatting section by default
      document.getElementById('textFormatSection').style.display = 'none';
      document.getElementById('gradientControls').style.display = 'none';
      document.getElementById('fillColorControl').style.display = 'block';
      
      if (!shape) {
        document.getElementById('fillType').value = 'solid';
        document.getElementById('fillColor').value = '#4a9eff';
        document.getElementById('strokeColor').value = '#000000';
        document.getElementById('strokeWidth').value = 2;
        document.getElementById('opacity').value = 1;
        document.getElementById('posX').value = 0;
        document.getElementById('posY').value = 0;
        document.getElementById('width').value = 100;
        document.getElementById('height').value = 100;
        document.getElementById('rotation').value = 0;
        document.getElementById('shadow').checked = false;
        document.getElementById('blur').value = 0;
        document.getElementById('blurValue').textContent = '0px';
        return;
      }

      // Show text formatting for text shapes
      if (shape.type === 'text') {
        document.getElementById('textFormatSection').style.display = 'block';
        if (shape.fontSize !== undefined) document.getElementById('fontSize').value = shape.fontSize;
        if (shape.fontWeight !== undefined) document.getElementById('fontWeight').value = shape.fontWeight;
        if (shape.fontStyle !== undefined) document.getElementById('fontStyle').value = shape.fontStyle;
        if (shape.textAlign !== undefined) document.getElementById('textAlign').value = shape.textAlign;
      }

      // Handle fill type (gradient or solid)
      if (shape.fillType === 'gradient') {
        document.getElementById('fillType').value = 'gradient';
        document.getElementById('fillColorControl').style.display = 'none';
        document.getElementById('gradientControls').style.display = 'block';
        if (shape.gradientStart) document.getElementById('gradientStart').value = shape.gradientStart;
        if (shape.gradientEnd) document.getElementById('gradientEnd').value = shape.gradientEnd;
        if (shape.gradientDirection) document.getElementById('gradientDirection').value = shape.gradientDirection;
      } else {
        document.getElementById('fillType').value = 'solid';
        if (shape.fill) document.getElementById('fillColor').value = shape.fill;
      }

      if (shape.stroke) document.getElementById('strokeColor').value = shape.stroke;
      if (shape.strokeWidth !== undefined) document.getElementById('strokeWidth').value = shape.strokeWidth;
      if (shape.opacity !== undefined) document.getElementById('opacity').value = shape.opacity;
      if (shape.x !== undefined) document.getElementById('posX').value = Math.round(shape.x);
      if (shape.y !== undefined) document.getElementById('posY').value = Math.round(shape.y);
      if (shape.width !== undefined) document.getElementById('width').value = Math.round(shape.width);
      if (shape.height !== undefined) document.getElementById('height').value = Math.round(shape.height);
      if (shape.rotation !== undefined) document.getElementById('rotation').value = shape.rotation;
      if (shape.shadow !== undefined) document.getElementById('shadow').checked = shape.shadow;
      if (shape.blur !== undefined) {
        document.getElementById('blur').value = shape.blur;
        document.getElementById('blurValue').textContent = shape.blur + 'px';
      }
    }

    // Property Change Handlers
    document.getElementById('fillType').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.fillType = e.target.value;
        if (e.target.value === 'gradient') {
          document.getElementById('fillColorControl').style.display = 'none';
          document.getElementById('gradientControls').style.display = 'block';
          if (!state.selectedShape.gradientStart) {
            state.selectedShape.gradientStart = state.selectedShape.fill || '#4a9eff';
            state.selectedShape.gradientEnd = '#3a8eef';
            state.selectedShape.gradientDirection = 'horizontal';
          }
        } else {
          document.getElementById('fillColorControl').style.display = 'block';
          document.getElementById('gradientControls').style.display = 'none';
        }
        redraw();
      }
    });

    document.getElementById('fillColor').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.fill = e.target.value;
        redraw();
      }
    });

    document.getElementById('gradientStart').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.gradientStart = e.target.value;
        redraw();
      }
    });

    document.getElementById('gradientEnd').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.gradientEnd = e.target.value;
        redraw();
      }
    });

    document.getElementById('gradientDirection').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.gradientDirection = e.target.value;
        redraw();
      }
    });

    // Text formatting handlers
    document.getElementById('fontSize').addEventListener('change', (e) => {
      if (state.selectedShape && state.selectedShape.type === 'text') {
        state.selectedShape.fontSize = parseInt(e.target.value);
        redraw();
      }
    });

    document.getElementById('fontWeight').addEventListener('change', (e) => {
      if (state.selectedShape && state.selectedShape.type === 'text') {
        state.selectedShape.fontWeight = e.target.value;
        redraw();
      }
    });

    document.getElementById('fontStyle').addEventListener('change', (e) => {
      if (state.selectedShape && state.selectedShape.type === 'text') {
        state.selectedShape.fontStyle = e.target.value;
        redraw();
      }
    });

    document.getElementById('textAlign').addEventListener('change', (e) => {
      if (state.selectedShape && state.selectedShape.type === 'text') {
        state.selectedShape.textAlign = e.target.value;
        redraw();
      }
    });

    document.getElementById('strokeColor').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.stroke = e.target.value;
        redraw();
      }
    });

    document.getElementById('strokeWidth').addEventListener('input', (e) => {
      if (state.selectedShape) {
        state.selectedShape.strokeWidth = parseInt(e.target.value);
        document.getElementById('strokeWidthValue').textContent = e.target.value + 'px';
        redraw();
      }
    });

    document.getElementById('opacity').addEventListener('input', (e) => {
      if (state.selectedShape) {
        state.selectedShape.opacity = parseFloat(e.target.value);
        document.getElementById('opacityValue').textContent = Math.round(e.target.value * 100) + '%';
        redraw();
      }
    });

    document.getElementById('posX').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.x = parseFloat(e.target.value);
        redraw();
      }
    });

    document.getElementById('posY').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.y = parseFloat(e.target.value);
        redraw();
      }
    });

    document.getElementById('width').addEventListener('change', (e) => {
      if (state.selectedShape && state.selectedShape.width !== undefined) {
        state.selectedShape.width = parseFloat(e.target.value);
        redraw();
      }
    });

    document.getElementById('height').addEventListener('change', (e) => {
      if (state.selectedShape && state.selectedShape.height !== undefined) {
        state.selectedShape.height = parseFloat(e.target.value);
        redraw();
      }
    });

    document.getElementById('rotation').addEventListener('input', (e) => {
      if (state.selectedShape) {
        state.selectedShape.rotation = parseFloat(e.target.value);
        document.getElementById('rotationValue').textContent = e.target.value + '¬∞';
        redraw();
      }
    });

    // Effects handlers
    document.getElementById('shadow').addEventListener('change', (e) => {
      if (state.selectedShape) {
        state.selectedShape.shadow = e.target.checked;
        if (state.selectedShape.shadow) {
          state.selectedShape.shadowColor = 'rgba(0, 0, 0, 0.3)';
          state.selectedShape.shadowBlur = 10;
          state.selectedShape.shadowOffsetX = 2;
          state.selectedShape.shadowOffsetY = 2;
        }
        redraw();
      }
    });

    document.getElementById('blur').addEventListener('input', (e) => {
      if (state.selectedShape) {
        state.selectedShape.blur = parseFloat(e.target.value);
        document.getElementById('blurValue').textContent = e.target.value + 'px';
        redraw();
      }
    });

    // Layers Panel
    function updateLayersList() {
      const list = document.getElementById('layersList');
      list.innerHTML = '';
      state.shapes.slice().reverse().forEach(shape => {
        const li = document.createElement('li');
        const isSelected = state.selectedShape === shape || state.selectedShapes.includes(shape);
        li.className = 'layer-item' + (isSelected ? ' selected' : '');
        li.innerHTML = `
          <div class="layer-visibility ${shape.visible !== false ? 'visible' : ''}" 
               onclick="event.stopPropagation(); toggleLayerVisibility(${shape.id})"></div>
          <span onclick="selectShapeById(${shape.id}, event)">${shape.type} (${shape.id})</span>
        `;
        list.appendChild(li);
      });
    }

    window.selectShapeById = (id, event) => {
      const shape = state.shapes.find(s => s.id === id);
      if (shape) {
        if (event && (event.shiftKey || event.metaKey || event.ctrlKey)) {
          // Multi-select
          if (state.selectedShapes.includes(shape)) {
            state.selectedShapes = state.selectedShapes.filter(s => s !== shape);
            if (state.selectedShapes.length === 0) {
              state.selectedShape = null;
            } else {
              state.selectedShape = state.selectedShapes[0];
            }
          } else {
            state.selectedShapes.push(shape);
            state.selectedShape = shape;
          }
          updateLayersList();
          redraw();
        } else {
          selectShape(shape);
          state.selectedShapes = [shape];
        }
      }
    };

    window.toggleLayerVisibility = (id) => {
      const shape = state.shapes.find(s => s.id === id);
      if (shape) {
        shape.visible = shape.visible === false ? true : false;
        updateLayersList();
        redraw();
      }
    };

    function deleteShape(shape) {
      saveState();
      const index = state.shapes.indexOf(shape);
      if (index > -1) {
        state.shapes.splice(index, 1);
        if (state.selectedShape === shape) {
          state.selectedShape = null;
        }
        state.selectedShapes = state.selectedShapes.filter(s => s !== shape);
        updateLayersList();
        redraw();
      }
    }

    function deleteSelectedShapes() {
      saveState();
      const shapesToDelete = state.selectedShapes.length > 0 ? state.selectedShapes : (state.selectedShape ? [state.selectedShape] : []);
      shapesToDelete.forEach(shape => {
        const index = state.shapes.indexOf(shape);
        if (index > -1) {
          state.shapes.splice(index, 1);
        }
      });
      state.selectedShape = null;
      state.selectedShapes = [];
      updateLayersList();
      redraw();
    }

    function copyShapes() {
      const shapesToCopy = state.selectedShapes.length > 0 ? state.selectedShapes : (state.selectedShape ? [state.selectedShape] : []);
      if (shapesToCopy.length > 0) {
        state.clipboard = shapesToCopy.map(shape => JSON.parse(JSON.stringify(shape)));
        updateStatus(`Copied ${shapesToCopy.length} shape(s)`);
      }
    }

    function pasteShapes() {
      if (state.clipboard.length === 0) return;
      
      saveState();
      const offset = 20; // Offset pasted shapes
      const pastedShapes = [];
      
      state.clipboard.forEach(clipboardShape => {
        const newShape = deepClone(clipboardShape);
        newShape.id = Date.now() + Math.random();
        newShape.x = (newShape.x || 0) + offset;
        newShape.y = (newShape.y || 0) + offset;
        state.shapes.push(newShape);
        pastedShapes.push(newShape);
      });
      
      if (pastedShapes.length > 0) {
        state.selectedShapes = pastedShapes;
        state.selectedShape = pastedShapes[0];
        updateLayersList();
        redraw();
        updateStatus(`Pasted ${pastedShapes.length} shape(s)`);
      }
    }

    function duplicateShapes() {
      const shapesToDuplicate = state.selectedShapes.length > 0 ? state.selectedShapes : (state.selectedShape ? [state.selectedShape] : []);
      if (shapesToDuplicate.length === 0) return;
      
      saveState();
      const offset = 20;
      const duplicatedShapes = [];
      
      shapesToDuplicate.forEach(shape => {
        const newShape = deepClone(shape);
        newShape.id = Date.now() + Math.random();
        newShape.x = (newShape.x || 0) + offset;
        newShape.y = (newShape.y || 0) + offset;
        state.shapes.push(newShape);
        duplicatedShapes.push(newShape);
      });
      
      if (duplicatedShapes.length > 0) {
        state.selectedShapes = duplicatedShapes;
        state.selectedShape = duplicatedShapes[0];
        updateLayersList();
        redraw();
        updateStatus(`Duplicated ${duplicatedShapes.length} shape(s)`);
      }
    }

    function groupShapes() {
      if (state.selectedShapes.length < 2) return;
      
      saveState();
      const groupId = 'group_' + Date.now();
      const minX = Math.min(...state.selectedShapes.map(s => s.x));
      const minY = Math.min(...state.selectedShapes.map(s => s.y));
      
      state.selectedShapes.forEach(shape => {
        shape._group = groupId;
        // Store relative position
        shape._groupOffsetX = shape.x - minX;
        shape._groupOffsetY = shape.y - minY;
      });
      
      updateStatus(`Grouped ${state.selectedShapes.length} shapes`);
      redraw();
    }

    function ungroupShapes() {
      if (!state.selectedShape || !state.selectedShape._group) return;
      
      saveState();
      const groupId = state.selectedShape._group;
      const groupedShapes = state.shapes.filter(s => s._group === groupId);
      
      groupedShapes.forEach(shape => {
        delete shape._group;
        delete shape._groupOffsetX;
        delete shape._groupOffsetY;
      });
      
      updateStatus(`Ungrouped ${groupedShapes.length} shapes`);
      redraw();
    }

    // Status Bar
    function updateStatus(text) {
      document.getElementById('statusText').textContent = text;
    }

    // Zoom
    canvas.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        state.zoom = Math.max(0.1, Math.min(5, state.zoom * delta));
        document.getElementById('zoomText').textContent = Math.round(state.zoom * 100) + '%';
        redraw();
      }
    });

    // Export/Save
    document.getElementById('saveBtn').addEventListener('click', () => {
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'design.png';
        a.click();
        // Revoke URL after a short delay to ensure download starts
        setTimeout(() => URL.revokeObjectURL(url), 100);
      });
    });

    // Undo/Redo - Use HistoryManager if available, otherwise fallback
    let history = [];
    let historyIndex = -1;
    let historyManager = null;
    
    // Initialize HistoryManager if available (will be set after module loads)
    setTimeout(() => {
      if (window.HistoryManager) {
        historyManager = new window.HistoryManager(50);
      }
    }, 100);

    // Use module function if available, otherwise fallback
    function deepClone(data) {
      if (window.cloneStateUtil) {
        return window.cloneStateUtil(data);
      }
      return JSON.parse(JSON.stringify(data));
    }
    
    // Also provide cloneShape for shape-specific cloning
    function cloneShape(shape) {
      if (window.cloneShapeUtil) {
        return window.cloneShapeUtil(shape);
      }
      return JSON.parse(JSON.stringify(shape));
    }

    function saveState() {
      if (historyManager) {
        historyManager.saveState(state.shapes, deepClone);
      } else {
        // Fallback to original implementation
        history = history.slice(0, historyIndex + 1);
        history.push(deepClone(state.shapes));
        historyIndex++;
        if (history.length > 50) {
          history.shift();
          historyIndex--;
        }
      }
    }

    function undo() {
      if (historyManager) {
        const previousState = historyManager.undo();
        if (previousState) {
          state.shapes = deepClone(previousState);
          updateLayersList();
          redraw();
        }
      } else {
        // Fallback to original implementation
        if (historyIndex > 0) {
          historyIndex--;
          state.shapes = deepClone(history[historyIndex]);
          updateLayersList();
          redraw();
        }
      }
    }

    function redo() {
      if (historyManager) {
        const nextState = historyManager.redo();
        if (nextState) {
          state.shapes = deepClone(nextState);
          updateLayersList();
          redraw();
        }
      } else {
        // Fallback to original implementation
        if (historyIndex < history.length - 1) {
          historyIndex++;
          state.shapes = deepClone(history[historyIndex]);
          updateLayersList();
          redraw();
        }
      }
    }

    // Component System
    state.components = [];
    state.componentInstances = new Map();

    // Use module if available, otherwise fallback
    function createComponent(shapes) {
      if (window.createComponentModule) {
        const component = window.createComponentModule(shapes, deepClone, state.components);
        updateComponentsList();
        return component;
      }
      // Fallback implementation
      const component = {
        id: 'comp_' + Date.now(),
        name: prompt('Component name:', 'Component ' + (state.components.length + 1)) || 'Component',
        shapes: deepClone(shapes),
        createdAt: Date.now()
      };
      state.components.push(component);
      updateComponentsList();
      return component;
    }

    // Use module if available, otherwise fallback
    function createComponentInstance(componentId, x, y) {
      if (window.createComponentInstanceModule) {
        const instance = window.createComponentInstanceModule(
          componentId, x, y, 
          state.components, 
          state.componentInstances, 
          state.shapes, 
          deepClone
        );
        if (instance) {
          updateLayersList();
          redraw();
        }
        return instance;
      }
      // Fallback implementation
      const component = state.components.find(c => c.id === componentId);
      if (!component) return;

      const instance = {
        id: 'inst_' + Date.now(),
        componentId: componentId,
        x: x,
        y: y,
        shapes: deepClone(component.shapes)
      };

      // Offset shapes to instance position
      instance.shapes.forEach(shape => {
        shape.x = (shape.x || 0) + x;
        shape.y = (shape.y || 0) + y;
        shape._instanceId = instance.id;
        shape._componentId = componentId;
      });

      state.shapes.push(...instance.shapes);
      state.componentInstances.set(instance.id, instance);
      updateLayersList();
      redraw();
      return instance;
    }

    // Use module if available, otherwise fallback
    function detachComponentInstance(shape) {
      if (window.detachComponentInstanceModule) {
        window.detachComponentInstanceModule(shape, state.componentInstances, state.shapes);
        updateLayersList();
        redraw();
        return;
      }
      // Fallback implementation
      if (shape._instanceId) {
        const instance = state.componentInstances.get(shape._instanceId);
        if (instance) {
          // Remove instance tracking
          state.shapes.forEach(s => {
            if (s._instanceId === instance.id) {
              delete s._instanceId;
              delete s._componentId;
            }
          });
          state.componentInstances.delete(instance.id);
          updateLayersList();
          redraw();
        }
      }
    }

    // Use module if available, otherwise fallback
    function updateComponentsList() {
      if (window.updateComponentsListModule) {
        window.updateComponentsListModule(
          state.components,
          (componentId, x, y) => createComponentInstance(componentId, x, y),
          updateComponentsList
        );
        return;
      }
      // Fallback implementation
      const list = document.getElementById('componentsList');
      list.innerHTML = '';
      state.components.forEach(comp => {
        const item = document.createElement('div');
        item.className = 'component-item';
        item.innerHTML = `
          <span>${comp.name}</span>
          <span class="component-badge">Component</span>
        `;
        item.onclick = () => {
          const pos = { x: canvas.width / 2 / state.zoom - state.panX, y: canvas.height / 2 / state.zoom - state.panY };
          createComponentInstance(comp.id, pos.x, pos.y);
        };
        list.appendChild(item);
      });
    }

    document.getElementById('createComponentBtn').addEventListener('click', () => {
      if (state.selectedShape) {
        // Create component from selected shape and its siblings in same group
        const shapes = state.shapes.filter(s => {
          // Simple: create from all selected shapes or just the selected one
          return s === state.selectedShape || (s._group && state.selectedShape._group && s._group === state.selectedShape._group);
        });
        if (shapes.length === 0) shapes.push(state.selectedShape);
        createComponent(shapes);
      } else {
        alert('Select a shape first to create a component');
      }
    });

    document.getElementById('detachComponentBtn').addEventListener('click', () => {
      if (state.selectedShape && state.selectedShape._instanceId) {
        detachComponentInstance(state.selectedShape);
      } else {
        alert('Select a component instance first');
      }
    });

    // Comments System
    state.comments = [];

    // Use module if available, otherwise fallback
    function addComment(x, y, text) {
      if (window.addCommentModule) {
        window.addCommentModule(x, y, text, state.comments);
        updateCommentsList();
        redrawComments();
        return state.comments[state.comments.length - 1];
      }
      // Fallback implementation
      const comment = {
        id: 'comment_' + Date.now(),
        x: x,
        y: y,
        text: text || '',
        createdAt: Date.now(),
        resolved: false
      };
      state.comments.push(comment);
      updateCommentsList();
      redrawComments();
      return comment;
    }

    // Use module if available, otherwise fallback
    function updateCommentsList() {
      if (window.updateCommentsListModule) {
        window.updateCommentsListModule(state.comments, redrawComments);
        return;
      }
      // Fallback implementation
      const list = document.getElementById('commentsList');
      list.innerHTML = '';
      state.comments.forEach(comment => {
        const item = document.createElement('div');
        item.className = 'layer-item';
        item.style.opacity = comment.resolved ? 0.5 : 1;
        item.innerHTML = `
          <span>üí¨ Comment ${state.comments.indexOf(comment) + 1}</span>
          <button class="btn" style="margin-left: auto; padding: 2px 6px; font-size: 10px;" 
                  onclick="resolveComment('${comment.id}')">${comment.resolved ? 'Unresolve' : 'Resolve'}</button>
        `;
        item.onclick = () => {
          // Center view on comment
          state.panX = -comment.x + canvas.width / 2 / state.zoom;
          state.panY = -comment.y + canvas.height / 2 / state.zoom;
          redraw();
          redrawComments();
        };
        list.appendChild(item);
      });
    }

    window.resolveComment = (id) => {
      const comment = state.comments.find(c => c.id === id);
      if (comment) {
        comment.resolved = !comment.resolved;
        updateCommentsList();
        redrawComments();
      }
    };

    // Use module if available, otherwise fallback
    function redrawComments() {
      if (window.redrawCommentsModule) {
        window.redrawCommentsModule(
          state.comments, 
          canvas, 
          state, 
          (comment, x, y) => showCommentPopup(comment, x, y)
        );
        return;
      }
      // Fallback implementation
      // Remove existing comment markers
      document.querySelectorAll('.comment-marker, .comment-popup').forEach(el => el.remove());

      const container = canvas.parentElement;
      state.comments.forEach(comment => {
        if (comment.resolved) return;

        const screenX = (comment.x + state.panX) * state.zoom;
        const screenY = (comment.y + state.panY) * state.zoom;

        const marker = document.createElement('div');
        marker.className = 'comment-marker';
        marker.style.left = screenX + 'px';
        marker.style.top = screenY + 'px';
        marker.textContent = state.comments.indexOf(comment) + 1;
        marker.onclick = (e) => {
          e.stopPropagation();
          showCommentPopup(comment, screenX, screenY);
        };
        container.appendChild(marker);
      });
    }

    // Use module if available, otherwise fallback
    function showCommentPopup(comment, x, y) {
      if (window.showCommentPopupModule) {
        window.showCommentPopupModule(comment, x, y, state.comments, canvas);
        return;
      }
      // Fallback implementation
      // Remove existing popup
      document.querySelectorAll('.comment-popup').forEach(el => el.remove());

      const popup = document.createElement('div');
      popup.className = 'comment-popup';
      popup.style.left = (x + 30) + 'px';
      popup.style.top = y + 'px';
      popup.innerHTML = `
        <textarea>${comment.text}</textarea>
        <div style="margin-top: 8px; display: flex; gap: 4px; justify-content: flex-end;">
          <button class="btn" onclick="this.closest('.comment-popup').remove()">Close</button>
          <button class="btn btn-primary" onclick="saveComment('${comment.id}', this.closest('.comment-popup').querySelector('textarea').value)">Save</button>
        </div>
      `;
      canvas.parentElement.appendChild(popup);

      // Close on outside click
      setTimeout(() => {
        document.addEventListener('click', function closePopup(e) {
          if (!popup.contains(e.target) && !e.target.classList.contains('comment-marker')) {
            popup.remove();
            document.removeEventListener('click', closePopup);
          }
        });
      }, 100);
    }

    window.saveComment = (id, text) => {
      const comment = state.comments.find(c => c.id === id);
      if (comment) {
        comment.text = text;
        updateCommentsList();
        document.querySelectorAll('.comment-popup').forEach(el => el.remove());
      }
    };

    document.getElementById('addCommentBtn').addEventListener('click', () => {
      const pos = { x: canvas.width / 2 / state.zoom - state.panX, y: canvas.height / 2 / state.zoom - state.panY };
      const text = prompt('Comment text:');
      if (text !== null) {
        addComment(pos.x, pos.y, text);
      }
    });

    // Asset Library
    const assetLibrary = {
      icons: ['‚≠ê', '‚ù§Ô∏è', 'üî•', 'üíé', 'üé®', 'üöÄ', '‚ö°', 'üåü', '‚ú®', 'üéØ', 'üí°', 'üîÆ', 'üé≠', 'üé™', 'üé¨', 'üéÆ', 'üé≤', 'üé∏', 'üé∫', 'üéª', 'ü•Å', 'üé§', 'üéß', 'üì±', 'üíª', '‚åö', 'üì∑', 'üé•', 'üì∫', 'üìª'],
      shapes: ['‚¨ú', '‚¨õ', 'üî≤', 'üî≥', 'üî¥', 'üü†', 'üü°', 'üü¢', 'üîµ', 'üü£', '‚ö´', '‚ö™', 'üü§'],
      ui: ['üìã', 'üìù', 'üìÑ', 'üìÉ', 'üìë', 'üîñ', 'üè∑Ô∏è', 'üìå', 'üìç', 'üìé', 'üñáÔ∏è', 'üìè', 'üìê', '‚úÇÔ∏è', 'üî®', 'üîß', 'üî©', '‚öôÔ∏è', 'üî´', 'üí£', 'üî™', 'üó°Ô∏è', '‚öîÔ∏è', 'üõ°Ô∏è', 'üö¨', '‚ö∞Ô∏è', '‚ö±Ô∏è', 'üè∫', 'üîÆ', 'üìø']
    };

    function populateAssetLibrary() {
      const grid = document.getElementById('assetGrid');
      grid.innerHTML = '';
      const allAssets = [...assetLibrary.icons, ...assetLibrary.shapes, ...assetLibrary.ui];
      
      allAssets.forEach((asset, idx) => {
        const item = document.createElement('div');
        item.className = 'asset-item';
        item.textContent = asset;
        item.title = `Asset ${idx + 1}`;
        item.onclick = () => {
          const pos = { x: canvas.width / 2 / state.zoom - state.panX, y: canvas.height / 2 / state.zoom - state.panY };
          createText(pos.x, pos.y, asset);
        };
        grid.appendChild(item);
      });
    }

    document.getElementById('assetSearch').addEventListener('input', (e) => {
      const search = e.target.value.toLowerCase();
      document.querySelectorAll('.asset-item').forEach(item => {
        const text = item.textContent || item.title || '';
        item.style.display = text.toLowerCase().includes(search) ? 'flex' : 'none';
      });
    });

    // Auto Layout
    state.autoLayout = {
      mode: 'none',
      padding: 8,
      gap: 8,
      autoResize: false
    };

    // Use module if available, otherwise fallback
    function applyAutoLayout(containerShape) {
      if (window.applyAutoLayoutModule) {
        window.applyAutoLayoutModule(
          containerShape, 
          state.shapes, 
          state.autoLayout, 
          redraw
        );
        return;
      }
      // Fallback implementation
      if (!containerShape || state.autoLayout.mode === 'none') return;

      const children = state.shapes.filter(s => 
        s !== containerShape &&
        s.x >= containerShape.x &&
        s.y >= containerShape.y &&
        s.x + (s.width || 0) <= containerShape.x + containerShape.width &&
        s.y + (s.height || 0) <= containerShape.y + containerShape.height
      );

      if (children.length === 0) return;

      const padding = state.autoLayout.padding;
      const gap = state.autoLayout.gap;
      let currentX = containerShape.x + padding;
      let currentY = containerShape.y + padding;
      let rowHeight = 0;

      children.forEach((child, idx) => {
        if (state.autoLayout.mode === 'hstack') {
          child.x = currentX;
          child.y = containerShape.y + padding;
          currentX += (child.width || 100) + gap;
          rowHeight = Math.max(rowHeight, child.height || 100);
        } else if (state.autoLayout.mode === 'vstack') {
          child.x = containerShape.x + padding;
          child.y = currentY;
          currentY += (child.height || 100) + gap;
        } else if (state.autoLayout.mode === 'grid') {
          const cols = Math.ceil(Math.sqrt(children.length));
          const col = idx % cols;
          const row = Math.floor(idx / cols);
          child.x = containerShape.x + padding + col * ((containerShape.width - padding * 2) / cols);
          child.y = containerShape.y + padding + row * ((containerShape.height - padding * 2) / Math.ceil(children.length / cols));
        }
      });

      if (state.autoLayout.autoResize && state.autoLayout.mode === 'hstack') {
        containerShape.width = currentX - gap - containerShape.x + padding;
        containerShape.height = rowHeight + padding * 2;
      } else if (state.autoLayout.autoResize && state.autoLayout.mode === 'vstack') {
        containerShape.height = currentY - gap - containerShape.y + padding;
      }

      redraw();
    }

    // Initialize auto-layout controls - Use module if available, otherwise fallback
    if (window.initAutoLayoutControlsModule) {
      window.initAutoLayoutControlsModule(
        state.autoLayout,
        () => {
          if (state.selectedShape && state.selectedShape.type === 'frame') {
            applyAutoLayout(state.selectedShape);
          }
        }
      );
    } else {
      // Fallback implementation
      document.querySelectorAll('.layout-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          state.autoLayout.mode = btn.dataset.layout;
          if (state.selectedShape && state.selectedShape.type === 'frame') {
            applyAutoLayout(state.selectedShape);
          }
        });
      });

      document.getElementById('layoutPadding').addEventListener('change', (e) => {
        state.autoLayout.padding = parseInt(e.target.value) || 0;
        if (state.selectedShape && state.selectedShape.type === 'frame') {
          applyAutoLayout(state.selectedShape);
        }
      });

      document.getElementById('layoutGap').addEventListener('change', (e) => {
        state.autoLayout.gap = parseInt(e.target.value) || 0;
        if (state.selectedShape && state.selectedShape.type === 'frame') {
          applyAutoLayout(state.selectedShape);
        }
      });

      document.getElementById('autoResize').addEventListener('change', (e) => {
        state.autoLayout.autoResize = e.target.checked;
        if (state.selectedShape && state.selectedShape.type === 'frame') {
          applyAutoLayout(state.selectedShape);
        }
      });
    }

    // Enhanced Vector Editing with B√©zier Curves
    state.editingPath = null;
    state.selectedPoint = null;
    state.selectedHandle = null;

    function enablePathEditing(shape) {
      if (shape.type !== 'pen' && shape.type !== 'pencil') return;
      state.editingPath = shape;
      state.penMode = true;
      redraw();
      drawBezierHandles(shape);
    }

    function drawBezierHandles(shape) {
      // Remove existing handles
      document.querySelectorAll('.bezier-handle, .bezier-line').forEach(el => el.remove());

      if (!shape.points || shape.points.length < 2) return;

      const container = canvas.parentElement;
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.width = canvas.width + 'px';
      svg.style.height = canvas.height + 'px';
      svg.style.pointerEvents = 'none';
      svg.style.zIndex = '999';

      shape.points.forEach((point, idx) => {
        if (point.handles) {
          const screenX = (point.x + state.panX) * state.zoom;
          const screenY = (point.y + state.panY) * state.zoom;

          // Draw handle lines
          if (point.handles.in) {
            const inX = (point.handles.in.x + state.panX) * state.zoom;
            const inY = (point.handles.in.y + state.panY) * state.zoom;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', screenX);
            line.setAttribute('y1', screenY);
            line.setAttribute('x2', inX);
            line.setAttribute('y2', inY);
            line.setAttribute('class', 'bezier-line');
            svg.appendChild(line);

            const handle = document.createElement('div');
            handle.className = 'bezier-handle';
            handle.style.left = (inX - 4) + 'px';
            handle.style.top = (inY - 4) + 'px';
            handle.dataset.pointIdx = idx;
            handle.dataset.handleType = 'in';
            handle.onmousedown = (e) => {
              e.stopPropagation();
              state.selectedPoint = idx;
              state.selectedHandle = 'in';
              handleMouseMoveForHandle(e);
            };
            container.appendChild(handle);
          }

          if (point.handles.out) {
            const outX = (point.handles.out.x + state.panX) * state.zoom;
            const outY = (point.handles.out.y + state.panY) * state.zoom;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', screenX);
            line.setAttribute('y1', screenY);
            line.setAttribute('x2', outX);
            line.setAttribute('y2', outY);
            line.setAttribute('class', 'bezier-line');
            svg.appendChild(line);

            const handle = document.createElement('div');
            handle.className = 'bezier-handle';
            handle.style.left = (outX - 4) + 'px';
            handle.style.top = (outY - 4) + 'px';
            handle.dataset.pointIdx = idx;
            handle.dataset.handleType = 'out';
            handle.onmousedown = (e) => {
              e.stopPropagation();
              state.selectedPoint = idx;
              state.selectedHandle = 'out';
              handleMouseMoveForHandle(e);
            };
            container.appendChild(handle);
          }
        }
      });

      container.appendChild(svg);
    }

    function handleMouseMoveForHandle(e) {
      const moveHandler = (ev) => {
        const pos = getCanvasPos(ev);
        if (state.editingPath && state.selectedPoint !== null && state.selectedHandle) {
          const point = state.editingPath.points[state.selectedPoint];
          if (!point.handles) point.handles = {};
          point.handles[state.selectedHandle] = { x: pos.x, y: pos.y };
          redraw();
          drawBezierHandles(state.editingPath);
        }
      };

      const upHandler = () => {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', upHandler);
        state.selectedPoint = null;
        state.selectedHandle = null;
      };

      document.addEventListener('mousemove', moveHandler);
      document.addEventListener('mouseup', upHandler);
    }

    // Update pen tool to support curves
    function addCurvePoint(shape, x, y) {
      if (!shape.points) shape.points = [];
      const point = {
        x: x,
        y: y,
        handles: {
          in: { x: x - 20, y: y },
          out: { x: x + 20, y: y }
        }
      };
      shape.points.push(point);
    }

    // Sketch File Support (using JSZip)
    async function loadJSZip() {
      if (window.JSZip) return window.JSZip;
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
        script.onload = () => resolve(window.JSZip);
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    async function importSketchFile(file) {
      try {
        const JSZip = await loadJSZip();
        const zip = await JSZip.loadAsync(file);
        
        // Sketch files contain a document.json
        const documentJson = await zip.file('document.json').async('string');
        const document = JSON.parse(documentJson);
        
        // Parse pages and layers (simplified)
        if (document.pages && document.pages[0]) {
          const page = document.pages[0];
          if (page.layers) {
            parseSketchLayers(page.layers, 0, 0);
            updateLayersList();
            redraw();
            updateStatus('Sketch file imported successfully');
          }
        }
      } catch (e) {
        console.error('Error importing sketch file:', e);
        alert('Error importing sketch file. Make sure it\'s a valid .sketch file.');
      }
    }

    function parseSketchLayers(layers, offsetX, offsetY) {
      layers.forEach(layer => {
        if (layer._class === 'shapePath' || layer._class === 'rectangle' || layer._class === 'oval') {
          const shape = {
            id: Date.now() + Math.random(),
            type: layer._class === 'oval' ? 'oval' : 'rect',
            x: (layer.frame?.x || 0) + offsetX,
            y: (layer.frame?.y || 0) + offsetY,
            width: layer.frame?.width || 100,
            height: layer.frame?.height || 100,
            fill: layer.style?.fills?.[0]?.color || '#4a9eff',
            stroke: layer.style?.borders?.[0]?.color || '#000',
            strokeWidth: layer.style?.borders?.[0]?.thickness || 1,
            opacity: layer.style?.contextSettings?.opacity || 1,
            rotation: 0
          };
          state.shapes.push(shape);
        } else if (layer.layers) {
          parseSketchLayers(layer.layers, offsetX + (layer.frame?.x || 0), offsetY + (layer.frame?.y || 0));
        }
      });
    }

    async function exportSketchFile() {
      try {
        const JSZip = await loadJSZip();
        const zip = new JSZip();
        
        // Create simplified sketch document structure
        const document = {
          _class: 'document',
          do_objectID: 'doc_' + Date.now(),
          assets: { _class: 'assetCollection' },
          colorSpace: 0,
          currentPageIndex: 0,
          pages: [{
            _class: 'page',
            do_objectID: 'page_' + Date.now(),
            layers: state.shapes.map(shape => sketchShapeToLayer(shape))
          }]
        };

        zip.file('document.json', JSON.stringify(document));
        const blob = await zip.generateAsync({ type: 'blob' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'design.sketch';
        a.click();
        URL.revokeObjectURL(url);
        updateStatus('Sketch file exported');
      } catch (e) {
        console.error('Error exporting sketch file:', e);
        alert('Error exporting sketch file');
      }
    }

    function sketchShapeToLayer(shape) {
      const layer = {
        _class: shape.type === 'oval' ? 'oval' : 'rectangle',
        do_objectID: 'layer_' + shape.id,
        frame: {
          _class: 'rect',
          x: shape.x || 0,
          y: shape.y || 0,
          width: shape.width || 100,
          height: shape.height || 100
        },
        style: {
          _class: 'style',
          fills: [{
            _class: 'fill',
            color: shape.fill || '#4a9eff'
          }],
          borders: [{
            _class: 'border',
            color: shape.stroke || '#000',
            thickness: shape.strokeWidth || 1
          }],
          contextSettings: {
            _class: 'graphicsContextSettings',
            opacity: shape.opacity || 1
          }
        }
      };
      return layer;
    }

    // Update export button to include sketch export
    document.getElementById('exportBtn').addEventListener('click', async () => {
      const format = confirm('Export as Sketch file? (OK for Sketch, Cancel for JSON)');
      if (format) {
        await exportSketchFile();
      } else {
        const data = JSON.stringify({
          shapes: state.shapes,
          components: state.components,
          comments: state.comments
        }, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'design.json';
        a.click();
        // Revoke URL after a short delay to ensure download starts
        setTimeout(() => URL.revokeObjectURL(url), 100);
      }
    });

    // Add sketch import to top bar
    const importBtn = document.createElement('button');
    importBtn.className = 'btn';
    importBtn.textContent = 'Import Sketch';
    importBtn.onclick = () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.sketch';
      input.onchange = (e) => {
        if (e.target.files[0]) {
          importSketchFile(e.target.files[0]);
        }
      };
      input.click();
    };
    document.querySelector('.top-bar-actions').insertBefore(importBtn, document.getElementById('exportBtn'));

    // Update redraw to include comments
    const originalRedraw = redraw;
    redraw = function() {
      originalRedraw();
      redrawComments();
    };

    // Initialize
    function init() {
      saveState();
      updateStatus('Ready');
      selectTool('select');
      populateAssetLibrary();
      updateComponentsList();
      updateCommentsList();
      
      // Load from localStorage if available - Use module if available
      try {
        const saved = window.loadStateUtil ? window.loadStateUtil() : null;
        if (saved) {
          const data = saved;
          if (data.shapes && Array.isArray(data.shapes)) {
            state.shapes = data.shapes;
          }
          if (data.components && Array.isArray(data.components)) {
            state.components = data.components;
            updateComponentsList();
          }
          if (data.comments && Array.isArray(data.comments)) {
            state.comments = data.comments;
            updateCommentsList();
          }
          if (data.autoLayout) {
            state.autoLayout = { ...state.autoLayout, ...data.autoLayout };
          }
          updateLayersList();
          redraw();
        } else {
          // Fallback to original localStorage access
          const savedStr = localStorage.getItem('designToolState');
          if (savedStr) {
            const data = JSON.parse(savedStr);
            if (data.shapes && Array.isArray(data.shapes)) {
              state.shapes = data.shapes;
            }
            if (data.components && Array.isArray(data.components)) {
              state.components = data.components;
              updateComponentsList();
            }
            if (data.comments && Array.isArray(data.comments)) {
              state.comments = data.comments;
              updateCommentsList();
            }
            if (data.autoLayout) {
              state.autoLayout = { ...state.autoLayout, ...data.autoLayout };
            }
            updateLayersList();
            redraw();
          }
        }
      } catch (e) {
        console.warn('Could not load saved state:', e);
      }
      
      // Auto-save periodically - Use module if available
      if (window.setupAutoSave) {
        window.setupAutoSave(state, 30000);
      } else {
        // Fallback to original implementation
        setInterval(() => {
          try {
            localStorage.setItem('designToolState', JSON.stringify({
              shapes: state.shapes,
              components: state.components,
              comments: state.comments,
              autoLayout: state.autoLayout
            }));
          } catch (e) {
            console.warn('Could not save state:', e);
          }
        }, 30000); // Every 30 seconds
      }
    }
    
    init();
  </script>
  <script type="module">
    // Import utility modules
    import { rgbToHex, hexToRgb } from './js/utils/color.js';
    import { cloneState, cloneShape } from './js/utils/clone.js';
    import { getCanvasPos, getScreenPos } from './js/utils/coordinates.js';
    import { saveState as saveStateUtil, loadState as loadStateUtil, setupAutoSave } from './js/utils/storage.js';
    import { HistoryManager } from './js/utils/history.js';
    
    // Import shape modules
    import { drawShape as drawShapeModule, drawGrid as drawGridModule } from './js/shapes/renderer.js';
    import { drawSelection as drawSelectionModule, getTransformHandles as getTransformHandlesModule, getHandleAt as getHandleAtModule, findShapeAt as findShapeAtModule, applyTransform as applyTransformModule, drawSelectionBox as drawSelectionBoxModule } from './js/shapes/selection.js';
    
    // Import features modules
    import { createComponent as createComponentModule, createComponentInstance as createComponentInstanceModule, detachComponentInstance as detachComponentInstanceModule, updateComponentsList as updateComponentsListModule } from './js/features/components.js';
    import { addComment as addCommentModule, updateCommentsList as updateCommentsListModule, redrawComments as redrawCommentsModule, showCommentPopup as showCommentPopupModule } from './js/features/comments.js';
    import { applyAutoLayout as applyAutoLayoutModule, initAutoLayoutControls as initAutoLayoutControlsModule } from './js/features/auto-layout.js';
    import { createVirtualList } from './js/core/virtual-list.js';
    
    // Make utilities available globally for backward compatibility
    window.rgbToHex = rgbToHex;
    window.hexToRgb = hexToRgb;
    window.cloneStateUtil = cloneState;
    window.cloneShapeUtil = cloneShape;
    window.getCanvasPosUtil = getCanvasPos;
    window.getScreenPosUtil = getScreenPos;
    window.saveStateUtil = saveStateUtil;
    window.loadStateUtil = loadStateUtil;
    window.setupAutoSave = setupAutoSave;
    window.HistoryManager = HistoryManager;
    window.debounceUtil = debounce;
    window.throttleUtil = throttle;
    window.rafThrottleUtil = rafThrottle;
    
    // Make shape modules available globally
    window.drawShapeModule = drawShapeModule;
    window.drawGridModule = drawGridModule;
    window.drawSelectionModule = drawSelectionModule;
    window.getTransformHandlesModule = getTransformHandlesModule;
    window.getHandleAtModule = getHandleAtModule;
    window.findShapeAtModule = findShapeAtModule;
    window.applyTransformModule = applyTransformModule;
    window.drawSelectionBoxModule = drawSelectionBoxModule;
    
    // Make features modules available globally
    window.createComponentModule = createComponentModule;
    window.createComponentInstanceModule = createComponentInstanceModule;
    window.detachComponentInstanceModule = detachComponentInstanceModule;
    window.updateComponentsListModule = updateComponentsListModule;
    window.addCommentModule = addCommentModule;
    window.updateCommentsListModule = updateCommentsListModule;
    window.redrawCommentsModule = redrawCommentsModule;
    window.showCommentPopupModule = showCommentPopupModule;
    window.applyAutoLayoutModule = applyAutoLayoutModule;
    window.initAutoLayoutControlsModule = initAutoLayoutControlsModule;
    window.createVirtualList = createVirtualList;
    window.showShapeContextMenuModule = showShapeContextMenuModule;
    window.showCanvasContextMenuModule = showCanvasContextMenuModule;
    window.hideContextMenuModule = hideContextMenuModule;
    window.showKeyboardHelpModule = showKeyboardHelpModule;
    window.hideKeyboardHelpModule = hideKeyboardHelpModule;
    
    // Note: window.redraw, window.canvas, window.ctx, and window.state are
    // initialized by the main script (lines 266-267 and 1592-1593) and should
    // NOT be set here. Modules depend on these globals being available.
    
    console.log('Module utilities, shapes, and features loaded');
  </script>
</body>
</html>
